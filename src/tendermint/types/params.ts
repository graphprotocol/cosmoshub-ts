// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.4.0
//   protoc        v3.21.7

import { Writer, Reader, Protobuf } from "as-proto";
import { google } from "../../google";

export class ConsensusParams {
  static encode(message: ConsensusParams, writer: Writer): void {
    const block = message.block;
    if (block !== null) {
      writer.uint32(10);
      writer.fork();
      BlockParams.encode(block, writer);
      writer.ldelim();
    }

    const evidence = message.evidence;
    if (evidence !== null) {
      writer.uint32(18);
      writer.fork();
      EvidenceParams.encode(evidence, writer);
      writer.ldelim();
    }

    const validator = message.validator;
    if (validator !== null) {
      writer.uint32(26);
      writer.fork();
      ValidatorParams.encode(validator, writer);
      writer.ldelim();
    }

    const version = message.version;
    if (version !== null) {
      writer.uint32(34);
      writer.fork();
      VersionParams.encode(version, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): ConsensusParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ConsensusParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.block = BlockParams.decode(reader, reader.uint32());
          break;

        case 2:
          message.evidence = EvidenceParams.decode(reader, reader.uint32());
          break;

        case 3:
          message.validator = ValidatorParams.decode(reader, reader.uint32());
          break;

        case 4:
          message.version = VersionParams.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  block: BlockParams | null;
  evidence: EvidenceParams | null;
  validator: ValidatorParams | null;
  version: VersionParams | null;

  constructor(
    block: BlockParams | null = null,
    evidence: EvidenceParams | null = null,
    validator: ValidatorParams | null = null,
    version: VersionParams | null = null
  ) {
    this.block = block;
    this.evidence = evidence;
    this.validator = validator;
    this.version = version;
  }
}

export function encodeConsensusParams(message: ConsensusParams): Uint8Array {
  return Protobuf.encode(message, ConsensusParams.encode);
}

export function decodeConsensusParams(buffer: Uint8Array): ConsensusParams {
  return Protobuf.decode<ConsensusParams>(buffer, ConsensusParams.decode);
}

@unmanaged
export class BlockParams {
  static encode(message: BlockParams, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.maxBytes);

    writer.uint32(16);
    writer.int64(message.maxGas);

    writer.uint32(24);
    writer.int64(message.timeIotaMs);
  }

  static decode(reader: Reader, length: i32): BlockParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new BlockParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxBytes = reader.int64();
          break;

        case 2:
          message.maxGas = reader.int64();
          break;

        case 3:
          message.timeIotaMs = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  maxBytes: i64;
  maxGas: i64;
  timeIotaMs: i64;

  constructor(maxBytes: i64 = 0, maxGas: i64 = 0, timeIotaMs: i64 = 0) {
    this.maxBytes = maxBytes;
    this.maxGas = maxGas;
    this.timeIotaMs = timeIotaMs;
  }
}

export function encodeBlockParams(message: BlockParams): Uint8Array {
  return Protobuf.encode(message, BlockParams.encode);
}

export function decodeBlockParams(buffer: Uint8Array): BlockParams {
  return Protobuf.decode<BlockParams>(buffer, BlockParams.decode);
}

@unmanaged
export class EvidenceParams {
  static encode(message: EvidenceParams, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.maxAgeNumBlocks);

    const maxAgeDuration = message.maxAgeDuration;
    if (maxAgeDuration !== null) {
      writer.uint32(18);
      writer.fork();
      google.protobuf.Duration.encode(maxAgeDuration, writer);
      writer.ldelim();
    }

    writer.uint32(24);
    writer.int64(message.maxBytes);
  }

  static decode(reader: Reader, length: i32): EvidenceParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new EvidenceParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxAgeNumBlocks = reader.int64();
          break;

        case 2:
          message.maxAgeDuration = google.protobuf.Duration.decode(
            reader,
            reader.uint32()
          );
          break;

        case 3:
          message.maxBytes = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  maxAgeNumBlocks: i64;
  maxAgeDuration: google.protobuf.Duration | null;
  maxBytes: i64;

  constructor(
    maxAgeNumBlocks: i64 = 0,
    maxAgeDuration: google.protobuf.Duration | null = null,
    maxBytes: i64 = 0
  ) {
    this.maxAgeNumBlocks = maxAgeNumBlocks;
    this.maxAgeDuration = maxAgeDuration;
    this.maxBytes = maxBytes;
  }
}

export function encodeEvidenceParams(message: EvidenceParams): Uint8Array {
  return Protobuf.encode(message, EvidenceParams.encode);
}

export function decodeEvidenceParams(buffer: Uint8Array): EvidenceParams {
  return Protobuf.decode<EvidenceParams>(buffer, EvidenceParams.decode);
}

export class ValidatorParams {
  static encode(message: ValidatorParams, writer: Writer): void {
    const pubKeyTypes = message.pubKeyTypes;
    if (pubKeyTypes.length !== 0) {
      for (let i = 0; i < pubKeyTypes.length; ++i) {
        writer.uint32(10);
        writer.string(pubKeyTypes[i]);
      }
    }
  }

  static decode(reader: Reader, length: i32): ValidatorParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ValidatorParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pubKeyTypes.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  pubKeyTypes: Array<string>;

  constructor(pubKeyTypes: Array<string> = []) {
    this.pubKeyTypes = pubKeyTypes;
  }
}

export function encodeValidatorParams(message: ValidatorParams): Uint8Array {
  return Protobuf.encode(message, ValidatorParams.encode);
}

export function decodeValidatorParams(buffer: Uint8Array): ValidatorParams {
  return Protobuf.decode<ValidatorParams>(buffer, ValidatorParams.decode);
}

@unmanaged
export class VersionParams {
  static encode(message: VersionParams, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.appVersion);
  }

  static decode(reader: Reader, length: i32): VersionParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new VersionParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.appVersion = reader.uint64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  appVersion: u64;

  constructor(appVersion: u64 = 0) {
    this.appVersion = appVersion;
  }
}

export function encodeVersionParams(message: VersionParams): Uint8Array {
  return Protobuf.encode(message, VersionParams.encode);
}

export function decodeVersionParams(buffer: Uint8Array): VersionParams {
  return Protobuf.decode<VersionParams>(buffer, VersionParams.decode);
}

@unmanaged
export class HashedParams {
  static encode(message: HashedParams, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.blockMaxBytes);

    writer.uint32(16);
    writer.int64(message.blockMaxGas);
  }

  static decode(reader: Reader, length: i32): HashedParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new HashedParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blockMaxBytes = reader.int64();
          break;

        case 2:
          message.blockMaxGas = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  blockMaxBytes: i64;
  blockMaxGas: i64;

  constructor(blockMaxBytes: i64 = 0, blockMaxGas: i64 = 0) {
    this.blockMaxBytes = blockMaxBytes;
    this.blockMaxGas = blockMaxGas;
  }
}

export function encodeHashedParams(message: HashedParams): Uint8Array {
  return Protobuf.encode(message, HashedParams.encode);
}

export function decodeHashedParams(buffer: Uint8Array): HashedParams {
  return Protobuf.decode<HashedParams>(buffer, HashedParams.decode);
}
