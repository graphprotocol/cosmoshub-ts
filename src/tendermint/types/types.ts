// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.4.0
//   protoc        v3.21.7

import { Writer, Reader, Protobuf } from "as-proto";
import { crypto } from "../crypto";
import { version } from "../version";
import { google } from "../../google";
import { ValidatorSet } from "./validator";

export class PartSetHeader {
  static encode(message: PartSetHeader, writer: Writer): void {
    writer.uint32(8);
    writer.uint32(message.total);

    writer.uint32(18);
    writer.bytes(message.hash);
  }

  static decode(reader: Reader, length: i32): PartSetHeader {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new PartSetHeader();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.total = reader.uint32();
          break;

        case 2:
          message.hash = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  total: u32;
  hash: Uint8Array;

  constructor(total: u32 = 0, hash: Uint8Array = new Uint8Array(0)) {
    this.total = total;
    this.hash = hash;
  }
}

export function encodePartSetHeader(message: PartSetHeader): Uint8Array {
  return Protobuf.encode(message, PartSetHeader.encode);
}

export function decodePartSetHeader(buffer: Uint8Array): PartSetHeader {
  return Protobuf.decode<PartSetHeader>(buffer, PartSetHeader.decode);
}

export class Part {
  static encode(message: Part, writer: Writer): void {
    writer.uint32(8);
    writer.uint32(message.index);

    writer.uint32(18);
    writer.bytes(message.bytes);

    const proof = message.proof;
    if (proof !== null) {
      writer.uint32(26);
      writer.fork();
      crypto.Proof.encode(proof, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Part {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Part();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = reader.uint32();
          break;

        case 2:
          message.bytes = reader.bytes();
          break;

        case 3:
          message.proof = crypto.Proof.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  index: u32;
  bytes: Uint8Array;
  proof: crypto.Proof | null;

  constructor(
    index: u32 = 0,
    bytes: Uint8Array = new Uint8Array(0),
    proof: crypto.Proof | null = null
  ) {
    this.index = index;
    this.bytes = bytes;
    this.proof = proof;
  }
}

export function encodePart(message: Part): Uint8Array {
  return Protobuf.encode(message, Part.encode);
}

export function decodePart(buffer: Uint8Array): Part {
  return Protobuf.decode<Part>(buffer, Part.decode);
}

export class BlockID {
  static encode(message: BlockID, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.hash);

    const partSetHeader = message.partSetHeader;
    if (partSetHeader !== null) {
      writer.uint32(18);
      writer.fork();
      PartSetHeader.encode(partSetHeader, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): BlockID {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new BlockID();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader.bytes();
          break;

        case 2:
          message.partSetHeader = PartSetHeader.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  hash: Uint8Array;
  partSetHeader: PartSetHeader | null;

  constructor(
    hash: Uint8Array = new Uint8Array(0),
    partSetHeader: PartSetHeader | null = null
  ) {
    this.hash = hash;
    this.partSetHeader = partSetHeader;
  }
}

export function encodeBlockID(message: BlockID): Uint8Array {
  return Protobuf.encode(message, BlockID.encode);
}

export function decodeBlockID(buffer: Uint8Array): BlockID {
  return Protobuf.decode<BlockID>(buffer, BlockID.decode);
}

export class Header {
  static encode(message: Header, writer: Writer): void {
    const version = message.version;
    if (version !== null) {
      writer.uint32(10);
      writer.fork();
      version.Consensus.encode(version, writer);
      writer.ldelim();
    }

    writer.uint32(18);
    writer.string(message.chainId);

    writer.uint32(24);
    writer.int64(message.height);

    const time = message.time;
    if (time !== null) {
      writer.uint32(34);
      writer.fork();
      google.protobuf.Timestamp.encode(time, writer);
      writer.ldelim();
    }

    const lastBlockId = message.lastBlockId;
    if (lastBlockId !== null) {
      writer.uint32(42);
      writer.fork();
      BlockID.encode(lastBlockId, writer);
      writer.ldelim();
    }

    writer.uint32(50);
    writer.bytes(message.lastCommitHash);

    writer.uint32(58);
    writer.bytes(message.dataHash);

    writer.uint32(66);
    writer.bytes(message.validatorsHash);

    writer.uint32(74);
    writer.bytes(message.nextValidatorsHash);

    writer.uint32(82);
    writer.bytes(message.consensusHash);

    writer.uint32(90);
    writer.bytes(message.appHash);

    writer.uint32(98);
    writer.bytes(message.lastResultsHash);

    writer.uint32(106);
    writer.bytes(message.evidenceHash);

    writer.uint32(114);
    writer.bytes(message.proposerAddress);
  }

  static decode(reader: Reader, length: i32): Header {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Header();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = version.Consensus.decode(reader, reader.uint32());
          break;

        case 2:
          message.chainId = reader.string();
          break;

        case 3:
          message.height = reader.int64();
          break;

        case 4:
          message.time = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 5:
          message.lastBlockId = BlockID.decode(reader, reader.uint32());
          break;

        case 6:
          message.lastCommitHash = reader.bytes();
          break;

        case 7:
          message.dataHash = reader.bytes();
          break;

        case 8:
          message.validatorsHash = reader.bytes();
          break;

        case 9:
          message.nextValidatorsHash = reader.bytes();
          break;

        case 10:
          message.consensusHash = reader.bytes();
          break;

        case 11:
          message.appHash = reader.bytes();
          break;

        case 12:
          message.lastResultsHash = reader.bytes();
          break;

        case 13:
          message.evidenceHash = reader.bytes();
          break;

        case 14:
          message.proposerAddress = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  version: version.Consensus | null;
  chainId: string;
  height: i64;
  time: google.protobuf.Timestamp | null;
  lastBlockId: BlockID | null;
  lastCommitHash: Uint8Array;
  dataHash: Uint8Array;
  validatorsHash: Uint8Array;
  nextValidatorsHash: Uint8Array;
  consensusHash: Uint8Array;
  appHash: Uint8Array;
  lastResultsHash: Uint8Array;
  evidenceHash: Uint8Array;
  proposerAddress: Uint8Array;

  constructor(
    version_: version.Consensus | null = null,
    chainId: string = "",
    height: i64 = 0,
    time: google.protobuf.Timestamp | null = null,
    lastBlockId: BlockID | null = null,
    lastCommitHash: Uint8Array = new Uint8Array(0),
    dataHash: Uint8Array = new Uint8Array(0),
    validatorsHash: Uint8Array = new Uint8Array(0),
    nextValidatorsHash: Uint8Array = new Uint8Array(0),
    consensusHash: Uint8Array = new Uint8Array(0),
    appHash: Uint8Array = new Uint8Array(0),
    lastResultsHash: Uint8Array = new Uint8Array(0),
    evidenceHash: Uint8Array = new Uint8Array(0),
    proposerAddress: Uint8Array = new Uint8Array(0)
  ) {
    this.version = version_;
    this.chainId = chainId;
    this.height = height;
    this.time = time;
    this.lastBlockId = lastBlockId;
    this.lastCommitHash = lastCommitHash;
    this.dataHash = dataHash;
    this.validatorsHash = validatorsHash;
    this.nextValidatorsHash = nextValidatorsHash;
    this.consensusHash = consensusHash;
    this.appHash = appHash;
    this.lastResultsHash = lastResultsHash;
    this.evidenceHash = evidenceHash;
    this.proposerAddress = proposerAddress;
  }
}

export function encodeHeader(message: Header): Uint8Array {
  return Protobuf.encode(message, Header.encode);
}

export function decodeHeader(buffer: Uint8Array): Header {
  return Protobuf.decode<Header>(buffer, Header.decode);
}

export class Data {
  static encode(message: Data, writer: Writer): void {
    const txs = message.txs;
    if (txs.length !== 0) {
      for (let i = 0; i < txs.length; ++i) {
        writer.uint32(10);
        writer.bytes(txs[i]);
      }
    }
  }

  static decode(reader: Reader, length: i32): Data {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Data();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.txs.push(reader.bytes());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  txs: Array<Uint8Array>;

  constructor(txs: Array<Uint8Array> = []) {
    this.txs = txs;
  }
}

export function encodeData(message: Data): Uint8Array {
  return Protobuf.encode(message, Data.encode);
}

export function decodeData(buffer: Uint8Array): Data {
  return Protobuf.decode<Data>(buffer, Data.decode);
}

export class Vote {
  static encode(message: Vote, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.type);

    writer.uint32(16);
    writer.int64(message.height);

    writer.uint32(24);
    writer.int32(message.round);

    const blockId = message.blockId;
    if (blockId !== null) {
      writer.uint32(34);
      writer.fork();
      BlockID.encode(blockId, writer);
      writer.ldelim();
    }

    const timestamp = message.timestamp;
    if (timestamp !== null) {
      writer.uint32(42);
      writer.fork();
      google.protobuf.Timestamp.encode(timestamp, writer);
      writer.ldelim();
    }

    writer.uint32(50);
    writer.bytes(message.validatorAddress);

    writer.uint32(56);
    writer.int32(message.validatorIndex);

    writer.uint32(66);
    writer.bytes(message.signature);
  }

  static decode(reader: Reader, length: i32): Vote {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Vote();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;

        case 2:
          message.height = reader.int64();
          break;

        case 3:
          message.round = reader.int32();
          break;

        case 4:
          message.blockId = BlockID.decode(reader, reader.uint32());
          break;

        case 5:
          message.timestamp = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 6:
          message.validatorAddress = reader.bytes();
          break;

        case 7:
          message.validatorIndex = reader.int32();
          break;

        case 8:
          message.signature = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  type: SignedMsgType;
  height: i64;
  round: i32;
  blockId: BlockID | null;
  timestamp: google.protobuf.Timestamp | null;
  validatorAddress: Uint8Array;
  validatorIndex: i32;
  signature: Uint8Array;

  constructor(
    type: SignedMsgType = 0,
    height: i64 = 0,
    round: i32 = 0,
    blockId: BlockID | null = null,
    timestamp: google.protobuf.Timestamp | null = null,
    validatorAddress: Uint8Array = new Uint8Array(0),
    validatorIndex: i32 = 0,
    signature: Uint8Array = new Uint8Array(0)
  ) {
    this.type = type;
    this.height = height;
    this.round = round;
    this.blockId = blockId;
    this.timestamp = timestamp;
    this.validatorAddress = validatorAddress;
    this.validatorIndex = validatorIndex;
    this.signature = signature;
  }
}

export function encodeVote(message: Vote): Uint8Array {
  return Protobuf.encode(message, Vote.encode);
}

export function decodeVote(buffer: Uint8Array): Vote {
  return Protobuf.decode<Vote>(buffer, Vote.decode);
}

export class Commit {
  static encode(message: Commit, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.height);

    writer.uint32(16);
    writer.int32(message.round);

    const blockId = message.blockId;
    if (blockId !== null) {
      writer.uint32(26);
      writer.fork();
      BlockID.encode(blockId, writer);
      writer.ldelim();
    }

    const signatures = message.signatures;
    for (let i = 0; i < signatures.length; ++i) {
      writer.uint32(34);
      writer.fork();
      CommitSig.encode(signatures[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Commit {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Commit();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = reader.int64();
          break;

        case 2:
          message.round = reader.int32();
          break;

        case 3:
          message.blockId = BlockID.decode(reader, reader.uint32());
          break;

        case 4:
          message.signatures.push(CommitSig.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  height: i64;
  round: i32;
  blockId: BlockID | null;
  signatures: Array<CommitSig>;

  constructor(
    height: i64 = 0,
    round: i32 = 0,
    blockId: BlockID | null = null,
    signatures: Array<CommitSig> = []
  ) {
    this.height = height;
    this.round = round;
    this.blockId = blockId;
    this.signatures = signatures;
  }
}

export function encodeCommit(message: Commit): Uint8Array {
  return Protobuf.encode(message, Commit.encode);
}

export function decodeCommit(buffer: Uint8Array): Commit {
  return Protobuf.decode<Commit>(buffer, Commit.decode);
}

export class CommitSig {
  static encode(message: CommitSig, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.blockIdFlag);

    writer.uint32(18);
    writer.bytes(message.validatorAddress);

    const timestamp = message.timestamp;
    if (timestamp !== null) {
      writer.uint32(26);
      writer.fork();
      google.protobuf.Timestamp.encode(timestamp, writer);
      writer.ldelim();
    }

    writer.uint32(34);
    writer.bytes(message.signature);
  }

  static decode(reader: Reader, length: i32): CommitSig {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CommitSig();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blockIdFlag = reader.int32();
          break;

        case 2:
          message.validatorAddress = reader.bytes();
          break;

        case 3:
          message.timestamp = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 4:
          message.signature = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  blockIdFlag: BlockIDFlag;
  validatorAddress: Uint8Array;
  timestamp: google.protobuf.Timestamp | null;
  signature: Uint8Array;

  constructor(
    blockIdFlag: BlockIDFlag = 0,
    validatorAddress: Uint8Array = new Uint8Array(0),
    timestamp: google.protobuf.Timestamp | null = null,
    signature: Uint8Array = new Uint8Array(0)
  ) {
    this.blockIdFlag = blockIdFlag;
    this.validatorAddress = validatorAddress;
    this.timestamp = timestamp;
    this.signature = signature;
  }
}

export function encodeCommitSig(message: CommitSig): Uint8Array {
  return Protobuf.encode(message, CommitSig.encode);
}

export function decodeCommitSig(buffer: Uint8Array): CommitSig {
  return Protobuf.decode<CommitSig>(buffer, CommitSig.decode);
}

export class Proposal {
  static encode(message: Proposal, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.type);

    writer.uint32(16);
    writer.int64(message.height);

    writer.uint32(24);
    writer.int32(message.round);

    writer.uint32(32);
    writer.int32(message.polRound);

    const blockId = message.blockId;
    if (blockId !== null) {
      writer.uint32(42);
      writer.fork();
      BlockID.encode(blockId, writer);
      writer.ldelim();
    }

    const timestamp = message.timestamp;
    if (timestamp !== null) {
      writer.uint32(50);
      writer.fork();
      google.protobuf.Timestamp.encode(timestamp, writer);
      writer.ldelim();
    }

    writer.uint32(58);
    writer.bytes(message.signature);
  }

  static decode(reader: Reader, length: i32): Proposal {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Proposal();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;

        case 2:
          message.height = reader.int64();
          break;

        case 3:
          message.round = reader.int32();
          break;

        case 4:
          message.polRound = reader.int32();
          break;

        case 5:
          message.blockId = BlockID.decode(reader, reader.uint32());
          break;

        case 6:
          message.timestamp = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 7:
          message.signature = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  type: SignedMsgType;
  height: i64;
  round: i32;
  polRound: i32;
  blockId: BlockID | null;
  timestamp: google.protobuf.Timestamp | null;
  signature: Uint8Array;

  constructor(
    type: SignedMsgType = 0,
    height: i64 = 0,
    round: i32 = 0,
    polRound: i32 = 0,
    blockId: BlockID | null = null,
    timestamp: google.protobuf.Timestamp | null = null,
    signature: Uint8Array = new Uint8Array(0)
  ) {
    this.type = type;
    this.height = height;
    this.round = round;
    this.polRound = polRound;
    this.blockId = blockId;
    this.timestamp = timestamp;
    this.signature = signature;
  }
}

export function encodeProposal(message: Proposal): Uint8Array {
  return Protobuf.encode(message, Proposal.encode);
}

export function decodeProposal(buffer: Uint8Array): Proposal {
  return Protobuf.decode<Proposal>(buffer, Proposal.decode);
}

export class SignedHeader {
  static encode(message: SignedHeader, writer: Writer): void {
    const header = message.header;
    if (header !== null) {
      writer.uint32(10);
      writer.fork();
      Header.encode(header, writer);
      writer.ldelim();
    }

    const commit = message.commit;
    if (commit !== null) {
      writer.uint32(18);
      writer.fork();
      Commit.encode(commit, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): SignedHeader {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new SignedHeader();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = Header.decode(reader, reader.uint32());
          break;

        case 2:
          message.commit = Commit.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  header: Header | null;
  commit: Commit | null;

  constructor(header: Header | null = null, commit: Commit | null = null) {
    this.header = header;
    this.commit = commit;
  }
}

export function encodeSignedHeader(message: SignedHeader): Uint8Array {
  return Protobuf.encode(message, SignedHeader.encode);
}

export function decodeSignedHeader(buffer: Uint8Array): SignedHeader {
  return Protobuf.decode<SignedHeader>(buffer, SignedHeader.decode);
}

export class LightBlock {
  static encode(message: LightBlock, writer: Writer): void {
    const signedHeader = message.signedHeader;
    if (signedHeader !== null) {
      writer.uint32(10);
      writer.fork();
      SignedHeader.encode(signedHeader, writer);
      writer.ldelim();
    }

    const validatorSet = message.validatorSet;
    if (validatorSet !== null) {
      writer.uint32(18);
      writer.fork();
      ValidatorSet.encode(validatorSet, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): LightBlock {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new LightBlock();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signedHeader = SignedHeader.decode(reader, reader.uint32());
          break;

        case 2:
          message.validatorSet = ValidatorSet.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  signedHeader: SignedHeader | null;
  validatorSet: ValidatorSet | null;

  constructor(
    signedHeader: SignedHeader | null = null,
    validatorSet: ValidatorSet | null = null
  ) {
    this.signedHeader = signedHeader;
    this.validatorSet = validatorSet;
  }
}

export function encodeLightBlock(message: LightBlock): Uint8Array {
  return Protobuf.encode(message, LightBlock.encode);
}

export function decodeLightBlock(buffer: Uint8Array): LightBlock {
  return Protobuf.decode<LightBlock>(buffer, LightBlock.decode);
}

export class BlockMeta {
  static encode(message: BlockMeta, writer: Writer): void {
    const blockId = message.blockId;
    if (blockId !== null) {
      writer.uint32(10);
      writer.fork();
      BlockID.encode(blockId, writer);
      writer.ldelim();
    }

    writer.uint32(16);
    writer.int64(message.blockSize);

    const header = message.header;
    if (header !== null) {
      writer.uint32(26);
      writer.fork();
      Header.encode(header, writer);
      writer.ldelim();
    }

    writer.uint32(32);
    writer.int64(message.numTxs);
  }

  static decode(reader: Reader, length: i32): BlockMeta {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new BlockMeta();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.blockId = BlockID.decode(reader, reader.uint32());
          break;

        case 2:
          message.blockSize = reader.int64();
          break;

        case 3:
          message.header = Header.decode(reader, reader.uint32());
          break;

        case 4:
          message.numTxs = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  blockId: BlockID | null;
  blockSize: i64;
  header: Header | null;
  numTxs: i64;

  constructor(
    blockId: BlockID | null = null,
    blockSize: i64 = 0,
    header: Header | null = null,
    numTxs: i64 = 0
  ) {
    this.blockId = blockId;
    this.blockSize = blockSize;
    this.header = header;
    this.numTxs = numTxs;
  }
}

export function encodeBlockMeta(message: BlockMeta): Uint8Array {
  return Protobuf.encode(message, BlockMeta.encode);
}

export function decodeBlockMeta(buffer: Uint8Array): BlockMeta {
  return Protobuf.decode<BlockMeta>(buffer, BlockMeta.decode);
}

export class TxProof {
  static encode(message: TxProof, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.rootHash);

    writer.uint32(18);
    writer.bytes(message.data);

    const proof = message.proof;
    if (proof !== null) {
      writer.uint32(26);
      writer.fork();
      crypto.Proof.encode(proof, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): TxProof {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new TxProof();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rootHash = reader.bytes();
          break;

        case 2:
          message.data = reader.bytes();
          break;

        case 3:
          message.proof = crypto.Proof.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  rootHash: Uint8Array;
  data: Uint8Array;
  proof: crypto.Proof | null;

  constructor(
    rootHash: Uint8Array = new Uint8Array(0),
    data: Uint8Array = new Uint8Array(0),
    proof: crypto.Proof | null = null
  ) {
    this.rootHash = rootHash;
    this.data = data;
    this.proof = proof;
  }
}

export function encodeTxProof(message: TxProof): Uint8Array {
  return Protobuf.encode(message, TxProof.encode);
}

export function decodeTxProof(buffer: Uint8Array): TxProof {
  return Protobuf.decode<TxProof>(buffer, TxProof.decode);
}

export enum BlockIDFlag {
  BLOCK_ID_FLAG_UNKNOWN = 0,
  BLOCK_ID_FLAG_ABSENT = 1,
  BLOCK_ID_FLAG_COMMIT = 2,
  BLOCK_ID_FLAG_NIL = 3,
}

export enum SignedMsgType {
  SIGNED_MSG_TYPE_UNKNOWN = 0,
  SIGNED_MSG_TYPE_PREVOTE = 1,
  SIGNED_MSG_TYPE_PRECOMMIT = 2,
  SIGNED_MSG_TYPE_PROPOSAL = 32,
}
