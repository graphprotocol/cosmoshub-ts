// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.4.0
//   protoc        v3.21.7

import { Writer, Reader, Protobuf } from "as-proto";
import { google } from "../../google";
import { types } from "../types";
import { crypto } from "../crypto";

export class Request {
  static encode(message: Request, writer: Writer): void {
    const echo = message.echo;
    if (echo !== null) {
      writer.uint32(10);
      writer.fork();
      RequestEcho.encode(echo, writer);
      writer.ldelim();
    }

    const flush = message.flush;
    if (flush !== null) {
      writer.uint32(18);
      writer.fork();
      RequestFlush.encode(flush, writer);
      writer.ldelim();
    }

    const info = message.info;
    if (info !== null) {
      writer.uint32(26);
      writer.fork();
      RequestInfo.encode(info, writer);
      writer.ldelim();
    }

    const setOption = message.setOption;
    if (setOption !== null) {
      writer.uint32(34);
      writer.fork();
      RequestSetOption.encode(setOption, writer);
      writer.ldelim();
    }

    const initChain = message.initChain;
    if (initChain !== null) {
      writer.uint32(42);
      writer.fork();
      RequestInitChain.encode(initChain, writer);
      writer.ldelim();
    }

    const query = message.query;
    if (query !== null) {
      writer.uint32(50);
      writer.fork();
      RequestQuery.encode(query, writer);
      writer.ldelim();
    }

    const beginBlock = message.beginBlock;
    if (beginBlock !== null) {
      writer.uint32(58);
      writer.fork();
      RequestBeginBlock.encode(beginBlock, writer);
      writer.ldelim();
    }

    const checkTx = message.checkTx;
    if (checkTx !== null) {
      writer.uint32(66);
      writer.fork();
      RequestCheckTx.encode(checkTx, writer);
      writer.ldelim();
    }

    const deliverTx = message.deliverTx;
    if (deliverTx !== null) {
      writer.uint32(74);
      writer.fork();
      RequestDeliverTx.encode(deliverTx, writer);
      writer.ldelim();
    }

    const endBlock = message.endBlock;
    if (endBlock !== null) {
      writer.uint32(82);
      writer.fork();
      RequestEndBlock.encode(endBlock, writer);
      writer.ldelim();
    }

    const commit = message.commit;
    if (commit !== null) {
      writer.uint32(90);
      writer.fork();
      RequestCommit.encode(commit, writer);
      writer.ldelim();
    }

    const listSnapshots = message.listSnapshots;
    if (listSnapshots !== null) {
      writer.uint32(98);
      writer.fork();
      RequestListSnapshots.encode(listSnapshots, writer);
      writer.ldelim();
    }

    const offerSnapshot = message.offerSnapshot;
    if (offerSnapshot !== null) {
      writer.uint32(106);
      writer.fork();
      RequestOfferSnapshot.encode(offerSnapshot, writer);
      writer.ldelim();
    }

    const loadSnapshotChunk = message.loadSnapshotChunk;
    if (loadSnapshotChunk !== null) {
      writer.uint32(114);
      writer.fork();
      RequestLoadSnapshotChunk.encode(loadSnapshotChunk, writer);
      writer.ldelim();
    }

    const applySnapshotChunk = message.applySnapshotChunk;
    if (applySnapshotChunk !== null) {
      writer.uint32(122);
      writer.fork();
      RequestApplySnapshotChunk.encode(applySnapshotChunk, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Request {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Request();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.echo = RequestEcho.decode(reader, reader.uint32());
          break;

        case 2:
          message.flush = RequestFlush.decode(reader, reader.uint32());
          break;

        case 3:
          message.info = RequestInfo.decode(reader, reader.uint32());
          break;

        case 4:
          message.setOption = RequestSetOption.decode(reader, reader.uint32());
          break;

        case 5:
          message.initChain = RequestInitChain.decode(reader, reader.uint32());
          break;

        case 6:
          message.query = RequestQuery.decode(reader, reader.uint32());
          break;

        case 7:
          message.beginBlock = RequestBeginBlock.decode(
            reader,
            reader.uint32()
          );
          break;

        case 8:
          message.checkTx = RequestCheckTx.decode(reader, reader.uint32());
          break;

        case 9:
          message.deliverTx = RequestDeliverTx.decode(reader, reader.uint32());
          break;

        case 10:
          message.endBlock = RequestEndBlock.decode(reader, reader.uint32());
          break;

        case 11:
          message.commit = RequestCommit.decode(reader, reader.uint32());
          break;

        case 12:
          message.listSnapshots = RequestListSnapshots.decode(
            reader,
            reader.uint32()
          );
          break;

        case 13:
          message.offerSnapshot = RequestOfferSnapshot.decode(
            reader,
            reader.uint32()
          );
          break;

        case 14:
          message.loadSnapshotChunk = RequestLoadSnapshotChunk.decode(
            reader,
            reader.uint32()
          );
          break;

        case 15:
          message.applySnapshotChunk = RequestApplySnapshotChunk.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  echo: RequestEcho | null;
  flush: RequestFlush | null;
  info: RequestInfo | null;
  setOption: RequestSetOption | null;
  initChain: RequestInitChain | null;
  query: RequestQuery | null;
  beginBlock: RequestBeginBlock | null;
  checkTx: RequestCheckTx | null;
  deliverTx: RequestDeliverTx | null;
  endBlock: RequestEndBlock | null;
  commit: RequestCommit | null;
  listSnapshots: RequestListSnapshots | null;
  offerSnapshot: RequestOfferSnapshot | null;
  loadSnapshotChunk: RequestLoadSnapshotChunk | null;
  applySnapshotChunk: RequestApplySnapshotChunk | null;

  constructor(
    echo: RequestEcho | null = null,
    flush: RequestFlush | null = null,
    info: RequestInfo | null = null,
    setOption: RequestSetOption | null = null,
    initChain: RequestInitChain | null = null,
    query: RequestQuery | null = null,
    beginBlock: RequestBeginBlock | null = null,
    checkTx: RequestCheckTx | null = null,
    deliverTx: RequestDeliverTx | null = null,
    endBlock: RequestEndBlock | null = null,
    commit: RequestCommit | null = null,
    listSnapshots: RequestListSnapshots | null = null,
    offerSnapshot: RequestOfferSnapshot | null = null,
    loadSnapshotChunk: RequestLoadSnapshotChunk | null = null,
    applySnapshotChunk: RequestApplySnapshotChunk | null = null
  ) {
    this.echo = echo;
    this.flush = flush;
    this.info = info;
    this.setOption = setOption;
    this.initChain = initChain;
    this.query = query;
    this.beginBlock = beginBlock;
    this.checkTx = checkTx;
    this.deliverTx = deliverTx;
    this.endBlock = endBlock;
    this.commit = commit;
    this.listSnapshots = listSnapshots;
    this.offerSnapshot = offerSnapshot;
    this.loadSnapshotChunk = loadSnapshotChunk;
    this.applySnapshotChunk = applySnapshotChunk;
  }
}

export function encodeRequest(message: Request): Uint8Array {
  return Protobuf.encode(message, Request.encode);
}

export function decodeRequest(buffer: Uint8Array): Request {
  return Protobuf.decode<Request>(buffer, Request.decode);
}

export class RequestEcho {
  static encode(message: RequestEcho, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.message);
  }

  static decode(reader: Reader, length: i32): RequestEcho {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestEcho();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  message: string;

  constructor(message: string = "") {
    this.message = message;
  }
}

export function encodeRequestEcho(message: RequestEcho): Uint8Array {
  return Protobuf.encode(message, RequestEcho.encode);
}

export function decodeRequestEcho(buffer: Uint8Array): RequestEcho {
  return Protobuf.decode<RequestEcho>(buffer, RequestEcho.decode);
}

@unmanaged
export class RequestFlush {
  static encode(message: RequestFlush, writer: Writer): void {}

  static decode(reader: Reader, length: i32): RequestFlush {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestFlush();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeRequestFlush(message: RequestFlush): Uint8Array {
  return Protobuf.encode(message, RequestFlush.encode);
}

export function decodeRequestFlush(buffer: Uint8Array): RequestFlush {
  return Protobuf.decode<RequestFlush>(buffer, RequestFlush.decode);
}

export class RequestInfo {
  static encode(message: RequestInfo, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.version);

    writer.uint32(16);
    writer.uint64(message.blockVersion);

    writer.uint32(24);
    writer.uint64(message.p2pVersion);
  }

  static decode(reader: Reader, length: i32): RequestInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.version = reader.string();
          break;

        case 2:
          message.blockVersion = reader.uint64();
          break;

        case 3:
          message.p2pVersion = reader.uint64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  version: string;
  blockVersion: u64;
  p2pVersion: u64;

  constructor(
    version: string = "",
    blockVersion: u64 = 0,
    p2pVersion: u64 = 0
  ) {
    this.version = version;
    this.blockVersion = blockVersion;
    this.p2pVersion = p2pVersion;
  }
}

export function encodeRequestInfo(message: RequestInfo): Uint8Array {
  return Protobuf.encode(message, RequestInfo.encode);
}

export function decodeRequestInfo(buffer: Uint8Array): RequestInfo {
  return Protobuf.decode<RequestInfo>(buffer, RequestInfo.decode);
}

export class RequestSetOption {
  static encode(message: RequestSetOption, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.key);

    writer.uint32(18);
    writer.string(message.value);
  }

  static decode(reader: Reader, length: i32): RequestSetOption {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestSetOption();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;

        case 2:
          message.value = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  key: string;
  value: string;

  constructor(key: string = "", value: string = "") {
    this.key = key;
    this.value = value;
  }
}

export function encodeRequestSetOption(message: RequestSetOption): Uint8Array {
  return Protobuf.encode(message, RequestSetOption.encode);
}

export function decodeRequestSetOption(buffer: Uint8Array): RequestSetOption {
  return Protobuf.decode<RequestSetOption>(buffer, RequestSetOption.decode);
}

export class RequestInitChain {
  static encode(message: RequestInitChain, writer: Writer): void {
    const time = message.time;
    if (time !== null) {
      writer.uint32(10);
      writer.fork();
      google.protobuf.Timestamp.encode(time, writer);
      writer.ldelim();
    }

    writer.uint32(18);
    writer.string(message.chainId);

    const consensusParams = message.consensusParams;
    if (consensusParams !== null) {
      writer.uint32(26);
      writer.fork();
      ConsensusParams.encode(consensusParams, writer);
      writer.ldelim();
    }

    const validators = message.validators;
    for (let i = 0; i < validators.length; ++i) {
      writer.uint32(34);
      writer.fork();
      ValidatorUpdate.encode(validators[i], writer);
      writer.ldelim();
    }

    writer.uint32(42);
    writer.bytes(message.appStateBytes);

    writer.uint32(48);
    writer.int64(message.initialHeight);
  }

  static decode(reader: Reader, length: i32): RequestInitChain {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestInitChain();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.time = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 2:
          message.chainId = reader.string();
          break;

        case 3:
          message.consensusParams = ConsensusParams.decode(
            reader,
            reader.uint32()
          );
          break;

        case 4:
          message.validators.push(
            ValidatorUpdate.decode(reader, reader.uint32())
          );
          break;

        case 5:
          message.appStateBytes = reader.bytes();
          break;

        case 6:
          message.initialHeight = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  time: google.protobuf.Timestamp | null;
  chainId: string;
  consensusParams: ConsensusParams | null;
  validators: Array<ValidatorUpdate>;
  appStateBytes: Uint8Array;
  initialHeight: i64;

  constructor(
    time: google.protobuf.Timestamp | null = null,
    chainId: string = "",
    consensusParams: ConsensusParams | null = null,
    validators: Array<ValidatorUpdate> = [],
    appStateBytes: Uint8Array = new Uint8Array(0),
    initialHeight: i64 = 0
  ) {
    this.time = time;
    this.chainId = chainId;
    this.consensusParams = consensusParams;
    this.validators = validators;
    this.appStateBytes = appStateBytes;
    this.initialHeight = initialHeight;
  }
}

export function encodeRequestInitChain(message: RequestInitChain): Uint8Array {
  return Protobuf.encode(message, RequestInitChain.encode);
}

export function decodeRequestInitChain(buffer: Uint8Array): RequestInitChain {
  return Protobuf.decode<RequestInitChain>(buffer, RequestInitChain.decode);
}

export class RequestQuery {
  static encode(message: RequestQuery, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.data);

    writer.uint32(18);
    writer.string(message.path);

    writer.uint32(24);
    writer.int64(message.height);

    writer.uint32(32);
    writer.bool(message.prove);
  }

  static decode(reader: Reader, length: i32): RequestQuery {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestQuery();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.data = reader.bytes();
          break;

        case 2:
          message.path = reader.string();
          break;

        case 3:
          message.height = reader.int64();
          break;

        case 4:
          message.prove = reader.bool();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  data: Uint8Array;
  path: string;
  height: i64;
  prove: bool;

  constructor(
    data: Uint8Array = new Uint8Array(0),
    path: string = "",
    height: i64 = 0,
    prove: bool = false
  ) {
    this.data = data;
    this.path = path;
    this.height = height;
    this.prove = prove;
  }
}

export function encodeRequestQuery(message: RequestQuery): Uint8Array {
  return Protobuf.encode(message, RequestQuery.encode);
}

export function decodeRequestQuery(buffer: Uint8Array): RequestQuery {
  return Protobuf.decode<RequestQuery>(buffer, RequestQuery.decode);
}

export class RequestBeginBlock {
  static encode(message: RequestBeginBlock, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.hash);

    const header = message.header;
    if (header !== null) {
      writer.uint32(18);
      writer.fork();
      types.Header.encode(header, writer);
      writer.ldelim();
    }

    const lastCommitInfo = message.lastCommitInfo;
    if (lastCommitInfo !== null) {
      writer.uint32(26);
      writer.fork();
      LastCommitInfo.encode(lastCommitInfo, writer);
      writer.ldelim();
    }

    const byzantineValidators = message.byzantineValidators;
    for (let i = 0; i < byzantineValidators.length; ++i) {
      writer.uint32(34);
      writer.fork();
      Evidence.encode(byzantineValidators[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): RequestBeginBlock {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestBeginBlock();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader.bytes();
          break;

        case 2:
          message.header = types.Header.decode(reader, reader.uint32());
          break;

        case 3:
          message.lastCommitInfo = LastCommitInfo.decode(
            reader,
            reader.uint32()
          );
          break;

        case 4:
          message.byzantineValidators.push(
            Evidence.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  hash: Uint8Array;
  header: types.Header | null;
  lastCommitInfo: LastCommitInfo | null;
  byzantineValidators: Array<Evidence>;

  constructor(
    hash: Uint8Array = new Uint8Array(0),
    header: types.Header | null = null,
    lastCommitInfo: LastCommitInfo | null = null,
    byzantineValidators: Array<Evidence> = []
  ) {
    this.hash = hash;
    this.header = header;
    this.lastCommitInfo = lastCommitInfo;
    this.byzantineValidators = byzantineValidators;
  }
}

export function encodeRequestBeginBlock(
  message: RequestBeginBlock
): Uint8Array {
  return Protobuf.encode(message, RequestBeginBlock.encode);
}

export function decodeRequestBeginBlock(buffer: Uint8Array): RequestBeginBlock {
  return Protobuf.decode<RequestBeginBlock>(buffer, RequestBeginBlock.decode);
}

export class RequestCheckTx {
  static encode(message: RequestCheckTx, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.tx);

    writer.uint32(16);
    writer.int32(message.type);
  }

  static decode(reader: Reader, length: i32): RequestCheckTx {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestCheckTx();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tx = reader.bytes();
          break;

        case 2:
          message.type = reader.int32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  tx: Uint8Array;
  type: CheckTxType;

  constructor(tx: Uint8Array = new Uint8Array(0), type: CheckTxType = 0) {
    this.tx = tx;
    this.type = type;
  }
}

export function encodeRequestCheckTx(message: RequestCheckTx): Uint8Array {
  return Protobuf.encode(message, RequestCheckTx.encode);
}

export function decodeRequestCheckTx(buffer: Uint8Array): RequestCheckTx {
  return Protobuf.decode<RequestCheckTx>(buffer, RequestCheckTx.decode);
}

export class RequestDeliverTx {
  static encode(message: RequestDeliverTx, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.tx);
  }

  static decode(reader: Reader, length: i32): RequestDeliverTx {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestDeliverTx();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tx = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  tx: Uint8Array;

  constructor(tx: Uint8Array = new Uint8Array(0)) {
    this.tx = tx;
  }
}

export function encodeRequestDeliverTx(message: RequestDeliverTx): Uint8Array {
  return Protobuf.encode(message, RequestDeliverTx.encode);
}

export function decodeRequestDeliverTx(buffer: Uint8Array): RequestDeliverTx {
  return Protobuf.decode<RequestDeliverTx>(buffer, RequestDeliverTx.decode);
}

@unmanaged
export class RequestEndBlock {
  static encode(message: RequestEndBlock, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.height);
  }

  static decode(reader: Reader, length: i32): RequestEndBlock {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestEndBlock();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  height: i64;

  constructor(height: i64 = 0) {
    this.height = height;
  }
}

export function encodeRequestEndBlock(message: RequestEndBlock): Uint8Array {
  return Protobuf.encode(message, RequestEndBlock.encode);
}

export function decodeRequestEndBlock(buffer: Uint8Array): RequestEndBlock {
  return Protobuf.decode<RequestEndBlock>(buffer, RequestEndBlock.decode);
}

@unmanaged
export class RequestCommit {
  static encode(message: RequestCommit, writer: Writer): void {}

  static decode(reader: Reader, length: i32): RequestCommit {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestCommit();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeRequestCommit(message: RequestCommit): Uint8Array {
  return Protobuf.encode(message, RequestCommit.encode);
}

export function decodeRequestCommit(buffer: Uint8Array): RequestCommit {
  return Protobuf.decode<RequestCommit>(buffer, RequestCommit.decode);
}

@unmanaged
export class RequestListSnapshots {
  static encode(message: RequestListSnapshots, writer: Writer): void {}

  static decode(reader: Reader, length: i32): RequestListSnapshots {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestListSnapshots();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeRequestListSnapshots(
  message: RequestListSnapshots
): Uint8Array {
  return Protobuf.encode(message, RequestListSnapshots.encode);
}

export function decodeRequestListSnapshots(
  buffer: Uint8Array
): RequestListSnapshots {
  return Protobuf.decode<RequestListSnapshots>(
    buffer,
    RequestListSnapshots.decode
  );
}

export class RequestOfferSnapshot {
  static encode(message: RequestOfferSnapshot, writer: Writer): void {
    const snapshot = message.snapshot;
    if (snapshot !== null) {
      writer.uint32(10);
      writer.fork();
      Snapshot.encode(snapshot, writer);
      writer.ldelim();
    }

    writer.uint32(18);
    writer.bytes(message.appHash);
  }

  static decode(reader: Reader, length: i32): RequestOfferSnapshot {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestOfferSnapshot();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.snapshot = Snapshot.decode(reader, reader.uint32());
          break;

        case 2:
          message.appHash = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  snapshot: Snapshot | null;
  appHash: Uint8Array;

  constructor(
    snapshot: Snapshot | null = null,
    appHash: Uint8Array = new Uint8Array(0)
  ) {
    this.snapshot = snapshot;
    this.appHash = appHash;
  }
}

export function encodeRequestOfferSnapshot(
  message: RequestOfferSnapshot
): Uint8Array {
  return Protobuf.encode(message, RequestOfferSnapshot.encode);
}

export function decodeRequestOfferSnapshot(
  buffer: Uint8Array
): RequestOfferSnapshot {
  return Protobuf.decode<RequestOfferSnapshot>(
    buffer,
    RequestOfferSnapshot.decode
  );
}

@unmanaged
export class RequestLoadSnapshotChunk {
  static encode(message: RequestLoadSnapshotChunk, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.height);

    writer.uint32(16);
    writer.uint32(message.format);

    writer.uint32(24);
    writer.uint32(message.chunk);
  }

  static decode(reader: Reader, length: i32): RequestLoadSnapshotChunk {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestLoadSnapshotChunk();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = reader.uint64();
          break;

        case 2:
          message.format = reader.uint32();
          break;

        case 3:
          message.chunk = reader.uint32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  height: u64;
  format: u32;
  chunk: u32;

  constructor(height: u64 = 0, format: u32 = 0, chunk: u32 = 0) {
    this.height = height;
    this.format = format;
    this.chunk = chunk;
  }
}

export function encodeRequestLoadSnapshotChunk(
  message: RequestLoadSnapshotChunk
): Uint8Array {
  return Protobuf.encode(message, RequestLoadSnapshotChunk.encode);
}

export function decodeRequestLoadSnapshotChunk(
  buffer: Uint8Array
): RequestLoadSnapshotChunk {
  return Protobuf.decode<RequestLoadSnapshotChunk>(
    buffer,
    RequestLoadSnapshotChunk.decode
  );
}

export class RequestApplySnapshotChunk {
  static encode(message: RequestApplySnapshotChunk, writer: Writer): void {
    writer.uint32(8);
    writer.uint32(message.index);

    writer.uint32(18);
    writer.bytes(message.chunk);

    writer.uint32(26);
    writer.string(message.sender);
  }

  static decode(reader: Reader, length: i32): RequestApplySnapshotChunk {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RequestApplySnapshotChunk();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.index = reader.uint32();
          break;

        case 2:
          message.chunk = reader.bytes();
          break;

        case 3:
          message.sender = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  index: u32;
  chunk: Uint8Array;
  sender: string;

  constructor(
    index: u32 = 0,
    chunk: Uint8Array = new Uint8Array(0),
    sender: string = ""
  ) {
    this.index = index;
    this.chunk = chunk;
    this.sender = sender;
  }
}

export function encodeRequestApplySnapshotChunk(
  message: RequestApplySnapshotChunk
): Uint8Array {
  return Protobuf.encode(message, RequestApplySnapshotChunk.encode);
}

export function decodeRequestApplySnapshotChunk(
  buffer: Uint8Array
): RequestApplySnapshotChunk {
  return Protobuf.decode<RequestApplySnapshotChunk>(
    buffer,
    RequestApplySnapshotChunk.decode
  );
}

export class Response {
  static encode(message: Response, writer: Writer): void {
    const exception = message.exception;
    if (exception !== null) {
      writer.uint32(10);
      writer.fork();
      ResponseException.encode(exception, writer);
      writer.ldelim();
    }

    const echo = message.echo;
    if (echo !== null) {
      writer.uint32(18);
      writer.fork();
      ResponseEcho.encode(echo, writer);
      writer.ldelim();
    }

    const flush = message.flush;
    if (flush !== null) {
      writer.uint32(26);
      writer.fork();
      ResponseFlush.encode(flush, writer);
      writer.ldelim();
    }

    const info = message.info;
    if (info !== null) {
      writer.uint32(34);
      writer.fork();
      ResponseInfo.encode(info, writer);
      writer.ldelim();
    }

    const setOption = message.setOption;
    if (setOption !== null) {
      writer.uint32(42);
      writer.fork();
      ResponseSetOption.encode(setOption, writer);
      writer.ldelim();
    }

    const initChain = message.initChain;
    if (initChain !== null) {
      writer.uint32(50);
      writer.fork();
      ResponseInitChain.encode(initChain, writer);
      writer.ldelim();
    }

    const query = message.query;
    if (query !== null) {
      writer.uint32(58);
      writer.fork();
      ResponseQuery.encode(query, writer);
      writer.ldelim();
    }

    const beginBlock = message.beginBlock;
    if (beginBlock !== null) {
      writer.uint32(66);
      writer.fork();
      ResponseBeginBlock.encode(beginBlock, writer);
      writer.ldelim();
    }

    const checkTx = message.checkTx;
    if (checkTx !== null) {
      writer.uint32(74);
      writer.fork();
      ResponseCheckTx.encode(checkTx, writer);
      writer.ldelim();
    }

    const deliverTx = message.deliverTx;
    if (deliverTx !== null) {
      writer.uint32(82);
      writer.fork();
      ResponseDeliverTx.encode(deliverTx, writer);
      writer.ldelim();
    }

    const endBlock = message.endBlock;
    if (endBlock !== null) {
      writer.uint32(90);
      writer.fork();
      ResponseEndBlock.encode(endBlock, writer);
      writer.ldelim();
    }

    const commit = message.commit;
    if (commit !== null) {
      writer.uint32(98);
      writer.fork();
      ResponseCommit.encode(commit, writer);
      writer.ldelim();
    }

    const listSnapshots = message.listSnapshots;
    if (listSnapshots !== null) {
      writer.uint32(106);
      writer.fork();
      ResponseListSnapshots.encode(listSnapshots, writer);
      writer.ldelim();
    }

    const offerSnapshot = message.offerSnapshot;
    if (offerSnapshot !== null) {
      writer.uint32(114);
      writer.fork();
      ResponseOfferSnapshot.encode(offerSnapshot, writer);
      writer.ldelim();
    }

    const loadSnapshotChunk = message.loadSnapshotChunk;
    if (loadSnapshotChunk !== null) {
      writer.uint32(122);
      writer.fork();
      ResponseLoadSnapshotChunk.encode(loadSnapshotChunk, writer);
      writer.ldelim();
    }

    const applySnapshotChunk = message.applySnapshotChunk;
    if (applySnapshotChunk !== null) {
      writer.uint32(130);
      writer.fork();
      ResponseApplySnapshotChunk.encode(applySnapshotChunk, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Response {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Response();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.exception = ResponseException.decode(reader, reader.uint32());
          break;

        case 2:
          message.echo = ResponseEcho.decode(reader, reader.uint32());
          break;

        case 3:
          message.flush = ResponseFlush.decode(reader, reader.uint32());
          break;

        case 4:
          message.info = ResponseInfo.decode(reader, reader.uint32());
          break;

        case 5:
          message.setOption = ResponseSetOption.decode(reader, reader.uint32());
          break;

        case 6:
          message.initChain = ResponseInitChain.decode(reader, reader.uint32());
          break;

        case 7:
          message.query = ResponseQuery.decode(reader, reader.uint32());
          break;

        case 8:
          message.beginBlock = ResponseBeginBlock.decode(
            reader,
            reader.uint32()
          );
          break;

        case 9:
          message.checkTx = ResponseCheckTx.decode(reader, reader.uint32());
          break;

        case 10:
          message.deliverTx = ResponseDeliverTx.decode(reader, reader.uint32());
          break;

        case 11:
          message.endBlock = ResponseEndBlock.decode(reader, reader.uint32());
          break;

        case 12:
          message.commit = ResponseCommit.decode(reader, reader.uint32());
          break;

        case 13:
          message.listSnapshots = ResponseListSnapshots.decode(
            reader,
            reader.uint32()
          );
          break;

        case 14:
          message.offerSnapshot = ResponseOfferSnapshot.decode(
            reader,
            reader.uint32()
          );
          break;

        case 15:
          message.loadSnapshotChunk = ResponseLoadSnapshotChunk.decode(
            reader,
            reader.uint32()
          );
          break;

        case 16:
          message.applySnapshotChunk = ResponseApplySnapshotChunk.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  exception: ResponseException | null;
  echo: ResponseEcho | null;
  flush: ResponseFlush | null;
  info: ResponseInfo | null;
  setOption: ResponseSetOption | null;
  initChain: ResponseInitChain | null;
  query: ResponseQuery | null;
  beginBlock: ResponseBeginBlock | null;
  checkTx: ResponseCheckTx | null;
  deliverTx: ResponseDeliverTx | null;
  endBlock: ResponseEndBlock | null;
  commit: ResponseCommit | null;
  listSnapshots: ResponseListSnapshots | null;
  offerSnapshot: ResponseOfferSnapshot | null;
  loadSnapshotChunk: ResponseLoadSnapshotChunk | null;
  applySnapshotChunk: ResponseApplySnapshotChunk | null;

  constructor(
    exception: ResponseException | null = null,
    echo: ResponseEcho | null = null,
    flush: ResponseFlush | null = null,
    info: ResponseInfo | null = null,
    setOption: ResponseSetOption | null = null,
    initChain: ResponseInitChain | null = null,
    query: ResponseQuery | null = null,
    beginBlock: ResponseBeginBlock | null = null,
    checkTx: ResponseCheckTx | null = null,
    deliverTx: ResponseDeliverTx | null = null,
    endBlock: ResponseEndBlock | null = null,
    commit: ResponseCommit | null = null,
    listSnapshots: ResponseListSnapshots | null = null,
    offerSnapshot: ResponseOfferSnapshot | null = null,
    loadSnapshotChunk: ResponseLoadSnapshotChunk | null = null,
    applySnapshotChunk: ResponseApplySnapshotChunk | null = null
  ) {
    this.exception = exception;
    this.echo = echo;
    this.flush = flush;
    this.info = info;
    this.setOption = setOption;
    this.initChain = initChain;
    this.query = query;
    this.beginBlock = beginBlock;
    this.checkTx = checkTx;
    this.deliverTx = deliverTx;
    this.endBlock = endBlock;
    this.commit = commit;
    this.listSnapshots = listSnapshots;
    this.offerSnapshot = offerSnapshot;
    this.loadSnapshotChunk = loadSnapshotChunk;
    this.applySnapshotChunk = applySnapshotChunk;
  }
}

export function encodeResponse(message: Response): Uint8Array {
  return Protobuf.encode(message, Response.encode);
}

export function decodeResponse(buffer: Uint8Array): Response {
  return Protobuf.decode<Response>(buffer, Response.decode);
}

export class ResponseException {
  static encode(message: ResponseException, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.error);
  }

  static decode(reader: Reader, length: i32): ResponseException {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseException();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.error = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  error: string;

  constructor(error: string = "") {
    this.error = error;
  }
}

export function encodeResponseException(
  message: ResponseException
): Uint8Array {
  return Protobuf.encode(message, ResponseException.encode);
}

export function decodeResponseException(buffer: Uint8Array): ResponseException {
  return Protobuf.decode<ResponseException>(buffer, ResponseException.decode);
}

export class ResponseEcho {
  static encode(message: ResponseEcho, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.message);
  }

  static decode(reader: Reader, length: i32): ResponseEcho {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseEcho();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.message = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  message: string;

  constructor(message: string = "") {
    this.message = message;
  }
}

export function encodeResponseEcho(message: ResponseEcho): Uint8Array {
  return Protobuf.encode(message, ResponseEcho.encode);
}

export function decodeResponseEcho(buffer: Uint8Array): ResponseEcho {
  return Protobuf.decode<ResponseEcho>(buffer, ResponseEcho.decode);
}

@unmanaged
export class ResponseFlush {
  static encode(message: ResponseFlush, writer: Writer): void {}

  static decode(reader: Reader, length: i32): ResponseFlush {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseFlush();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeResponseFlush(message: ResponseFlush): Uint8Array {
  return Protobuf.encode(message, ResponseFlush.encode);
}

export function decodeResponseFlush(buffer: Uint8Array): ResponseFlush {
  return Protobuf.decode<ResponseFlush>(buffer, ResponseFlush.decode);
}

export class ResponseInfo {
  static encode(message: ResponseInfo, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.data);

    writer.uint32(18);
    writer.string(message.version);

    writer.uint32(24);
    writer.uint64(message.appVersion);

    writer.uint32(32);
    writer.int64(message.lastBlockHeight);

    writer.uint32(42);
    writer.bytes(message.lastBlockAppHash);
  }

  static decode(reader: Reader, length: i32): ResponseInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.data = reader.string();
          break;

        case 2:
          message.version = reader.string();
          break;

        case 3:
          message.appVersion = reader.uint64();
          break;

        case 4:
          message.lastBlockHeight = reader.int64();
          break;

        case 5:
          message.lastBlockAppHash = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  data: string;
  version: string;
  appVersion: u64;
  lastBlockHeight: i64;
  lastBlockAppHash: Uint8Array;

  constructor(
    data: string = "",
    version: string = "",
    appVersion: u64 = 0,
    lastBlockHeight: i64 = 0,
    lastBlockAppHash: Uint8Array = new Uint8Array(0)
  ) {
    this.data = data;
    this.version = version;
    this.appVersion = appVersion;
    this.lastBlockHeight = lastBlockHeight;
    this.lastBlockAppHash = lastBlockAppHash;
  }
}

export function encodeResponseInfo(message: ResponseInfo): Uint8Array {
  return Protobuf.encode(message, ResponseInfo.encode);
}

export function decodeResponseInfo(buffer: Uint8Array): ResponseInfo {
  return Protobuf.decode<ResponseInfo>(buffer, ResponseInfo.decode);
}

export class ResponseSetOption {
  static encode(message: ResponseSetOption, writer: Writer): void {
    writer.uint32(8);
    writer.uint32(message.code);

    writer.uint32(26);
    writer.string(message.log);

    writer.uint32(34);
    writer.string(message.info);
  }

  static decode(reader: Reader, length: i32): ResponseSetOption {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseSetOption();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code = reader.uint32();
          break;

        case 3:
          message.log = reader.string();
          break;

        case 4:
          message.info = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  code: u32;
  log: string;
  info: string;

  constructor(code: u32 = 0, log: string = "", info: string = "") {
    this.code = code;
    this.log = log;
    this.info = info;
  }
}

export function encodeResponseSetOption(
  message: ResponseSetOption
): Uint8Array {
  return Protobuf.encode(message, ResponseSetOption.encode);
}

export function decodeResponseSetOption(buffer: Uint8Array): ResponseSetOption {
  return Protobuf.decode<ResponseSetOption>(buffer, ResponseSetOption.decode);
}

export class ResponseInitChain {
  static encode(message: ResponseInitChain, writer: Writer): void {
    const consensusParams = message.consensusParams;
    if (consensusParams !== null) {
      writer.uint32(10);
      writer.fork();
      ConsensusParams.encode(consensusParams, writer);
      writer.ldelim();
    }

    const validators = message.validators;
    for (let i = 0; i < validators.length; ++i) {
      writer.uint32(18);
      writer.fork();
      ValidatorUpdate.encode(validators[i], writer);
      writer.ldelim();
    }

    writer.uint32(26);
    writer.bytes(message.appHash);
  }

  static decode(reader: Reader, length: i32): ResponseInitChain {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseInitChain();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.consensusParams = ConsensusParams.decode(
            reader,
            reader.uint32()
          );
          break;

        case 2:
          message.validators.push(
            ValidatorUpdate.decode(reader, reader.uint32())
          );
          break;

        case 3:
          message.appHash = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  consensusParams: ConsensusParams | null;
  validators: Array<ValidatorUpdate>;
  appHash: Uint8Array;

  constructor(
    consensusParams: ConsensusParams | null = null,
    validators: Array<ValidatorUpdate> = [],
    appHash: Uint8Array = new Uint8Array(0)
  ) {
    this.consensusParams = consensusParams;
    this.validators = validators;
    this.appHash = appHash;
  }
}

export function encodeResponseInitChain(
  message: ResponseInitChain
): Uint8Array {
  return Protobuf.encode(message, ResponseInitChain.encode);
}

export function decodeResponseInitChain(buffer: Uint8Array): ResponseInitChain {
  return Protobuf.decode<ResponseInitChain>(buffer, ResponseInitChain.decode);
}

export class ResponseQuery {
  static encode(message: ResponseQuery, writer: Writer): void {
    writer.uint32(8);
    writer.uint32(message.code);

    writer.uint32(26);
    writer.string(message.log);

    writer.uint32(34);
    writer.string(message.info);

    writer.uint32(40);
    writer.int64(message.index);

    writer.uint32(50);
    writer.bytes(message.key);

    writer.uint32(58);
    writer.bytes(message.value);

    const proofOps = message.proofOps;
    if (proofOps !== null) {
      writer.uint32(66);
      writer.fork();
      crypto.ProofOps.encode(proofOps, writer);
      writer.ldelim();
    }

    writer.uint32(72);
    writer.int64(message.height);

    writer.uint32(82);
    writer.string(message.codespace);
  }

  static decode(reader: Reader, length: i32): ResponseQuery {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseQuery();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code = reader.uint32();
          break;

        case 3:
          message.log = reader.string();
          break;

        case 4:
          message.info = reader.string();
          break;

        case 5:
          message.index = reader.int64();
          break;

        case 6:
          message.key = reader.bytes();
          break;

        case 7:
          message.value = reader.bytes();
          break;

        case 8:
          message.proofOps = crypto.ProofOps.decode(reader, reader.uint32());
          break;

        case 9:
          message.height = reader.int64();
          break;

        case 10:
          message.codespace = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  code: u32;
  log: string;
  info: string;
  index: i64;
  key: Uint8Array;
  value: Uint8Array;
  proofOps: crypto.ProofOps | null;
  height: i64;
  codespace: string;

  constructor(
    code: u32 = 0,
    log: string = "",
    info: string = "",
    index: i64 = 0,
    key: Uint8Array = new Uint8Array(0),
    value: Uint8Array = new Uint8Array(0),
    proofOps: crypto.ProofOps | null = null,
    height: i64 = 0,
    codespace: string = ""
  ) {
    this.code = code;
    this.log = log;
    this.info = info;
    this.index = index;
    this.key = key;
    this.value = value;
    this.proofOps = proofOps;
    this.height = height;
    this.codespace = codespace;
  }
}

export function encodeResponseQuery(message: ResponseQuery): Uint8Array {
  return Protobuf.encode(message, ResponseQuery.encode);
}

export function decodeResponseQuery(buffer: Uint8Array): ResponseQuery {
  return Protobuf.decode<ResponseQuery>(buffer, ResponseQuery.decode);
}

export class ResponseBeginBlock {
  static encode(message: ResponseBeginBlock, writer: Writer): void {
    const events = message.events;
    for (let i = 0; i < events.length; ++i) {
      writer.uint32(10);
      writer.fork();
      Event.encode(events[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): ResponseBeginBlock {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseBeginBlock();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.events.push(Event.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  events: Array<Event>;

  constructor(events: Array<Event> = []) {
    this.events = events;
  }
}

export function encodeResponseBeginBlock(
  message: ResponseBeginBlock
): Uint8Array {
  return Protobuf.encode(message, ResponseBeginBlock.encode);
}

export function decodeResponseBeginBlock(
  buffer: Uint8Array
): ResponseBeginBlock {
  return Protobuf.decode<ResponseBeginBlock>(buffer, ResponseBeginBlock.decode);
}

export class ResponseCheckTx {
  static encode(message: ResponseCheckTx, writer: Writer): void {
    writer.uint32(8);
    writer.uint32(message.code);

    writer.uint32(18);
    writer.bytes(message.data);

    writer.uint32(26);
    writer.string(message.log);

    writer.uint32(34);
    writer.string(message.info);

    writer.uint32(40);
    writer.int64(message.gasWanted);

    writer.uint32(48);
    writer.int64(message.gasUsed);

    const events = message.events;
    for (let i = 0; i < events.length; ++i) {
      writer.uint32(58);
      writer.fork();
      Event.encode(events[i], writer);
      writer.ldelim();
    }

    writer.uint32(66);
    writer.string(message.codespace);
  }

  static decode(reader: Reader, length: i32): ResponseCheckTx {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseCheckTx();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code = reader.uint32();
          break;

        case 2:
          message.data = reader.bytes();
          break;

        case 3:
          message.log = reader.string();
          break;

        case 4:
          message.info = reader.string();
          break;

        case 5:
          message.gasWanted = reader.int64();
          break;

        case 6:
          message.gasUsed = reader.int64();
          break;

        case 7:
          message.events.push(Event.decode(reader, reader.uint32()));
          break;

        case 8:
          message.codespace = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  code: u32;
  data: Uint8Array;
  log: string;
  info: string;
  gasWanted: i64;
  gasUsed: i64;
  events: Array<Event>;
  codespace: string;

  constructor(
    code: u32 = 0,
    data: Uint8Array = new Uint8Array(0),
    log: string = "",
    info: string = "",
    gasWanted: i64 = 0,
    gasUsed: i64 = 0,
    events: Array<Event> = [],
    codespace: string = ""
  ) {
    this.code = code;
    this.data = data;
    this.log = log;
    this.info = info;
    this.gasWanted = gasWanted;
    this.gasUsed = gasUsed;
    this.events = events;
    this.codespace = codespace;
  }
}

export function encodeResponseCheckTx(message: ResponseCheckTx): Uint8Array {
  return Protobuf.encode(message, ResponseCheckTx.encode);
}

export function decodeResponseCheckTx(buffer: Uint8Array): ResponseCheckTx {
  return Protobuf.decode<ResponseCheckTx>(buffer, ResponseCheckTx.decode);
}

export class ResponseDeliverTx {
  static encode(message: ResponseDeliverTx, writer: Writer): void {
    writer.uint32(8);
    writer.uint32(message.code);

    writer.uint32(18);
    writer.bytes(message.data);

    writer.uint32(26);
    writer.string(message.log);

    writer.uint32(34);
    writer.string(message.info);

    writer.uint32(40);
    writer.int64(message.gasWanted);

    writer.uint32(48);
    writer.int64(message.gasUsed);

    const events = message.events;
    for (let i = 0; i < events.length; ++i) {
      writer.uint32(58);
      writer.fork();
      Event.encode(events[i], writer);
      writer.ldelim();
    }

    writer.uint32(66);
    writer.string(message.codespace);
  }

  static decode(reader: Reader, length: i32): ResponseDeliverTx {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseDeliverTx();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.code = reader.uint32();
          break;

        case 2:
          message.data = reader.bytes();
          break;

        case 3:
          message.log = reader.string();
          break;

        case 4:
          message.info = reader.string();
          break;

        case 5:
          message.gasWanted = reader.int64();
          break;

        case 6:
          message.gasUsed = reader.int64();
          break;

        case 7:
          message.events.push(Event.decode(reader, reader.uint32()));
          break;

        case 8:
          message.codespace = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  code: u32;
  data: Uint8Array;
  log: string;
  info: string;
  gasWanted: i64;
  gasUsed: i64;
  events: Array<Event>;
  codespace: string;

  constructor(
    code: u32 = 0,
    data: Uint8Array = new Uint8Array(0),
    log: string = "",
    info: string = "",
    gasWanted: i64 = 0,
    gasUsed: i64 = 0,
    events: Array<Event> = [],
    codespace: string = ""
  ) {
    this.code = code;
    this.data = data;
    this.log = log;
    this.info = info;
    this.gasWanted = gasWanted;
    this.gasUsed = gasUsed;
    this.events = events;
    this.codespace = codespace;
  }
}

export function encodeResponseDeliverTx(
  message: ResponseDeliverTx
): Uint8Array {
  return Protobuf.encode(message, ResponseDeliverTx.encode);
}

export function decodeResponseDeliverTx(buffer: Uint8Array): ResponseDeliverTx {
  return Protobuf.decode<ResponseDeliverTx>(buffer, ResponseDeliverTx.decode);
}

export class ResponseEndBlock {
  static encode(message: ResponseEndBlock, writer: Writer): void {
    const validatorUpdates = message.validatorUpdates;
    for (let i = 0; i < validatorUpdates.length; ++i) {
      writer.uint32(10);
      writer.fork();
      ValidatorUpdate.encode(validatorUpdates[i], writer);
      writer.ldelim();
    }

    const consensusParamUpdates = message.consensusParamUpdates;
    if (consensusParamUpdates !== null) {
      writer.uint32(18);
      writer.fork();
      ConsensusParams.encode(consensusParamUpdates, writer);
      writer.ldelim();
    }

    const events = message.events;
    for (let i = 0; i < events.length; ++i) {
      writer.uint32(26);
      writer.fork();
      Event.encode(events[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): ResponseEndBlock {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseEndBlock();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.validatorUpdates.push(
            ValidatorUpdate.decode(reader, reader.uint32())
          );
          break;

        case 2:
          message.consensusParamUpdates = ConsensusParams.decode(
            reader,
            reader.uint32()
          );
          break;

        case 3:
          message.events.push(Event.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  validatorUpdates: Array<ValidatorUpdate>;
  consensusParamUpdates: ConsensusParams | null;
  events: Array<Event>;

  constructor(
    validatorUpdates: Array<ValidatorUpdate> = [],
    consensusParamUpdates: ConsensusParams | null = null,
    events: Array<Event> = []
  ) {
    this.validatorUpdates = validatorUpdates;
    this.consensusParamUpdates = consensusParamUpdates;
    this.events = events;
  }
}

export function encodeResponseEndBlock(message: ResponseEndBlock): Uint8Array {
  return Protobuf.encode(message, ResponseEndBlock.encode);
}

export function decodeResponseEndBlock(buffer: Uint8Array): ResponseEndBlock {
  return Protobuf.decode<ResponseEndBlock>(buffer, ResponseEndBlock.decode);
}

export class ResponseCommit {
  static encode(message: ResponseCommit, writer: Writer): void {
    writer.uint32(18);
    writer.bytes(message.data);

    writer.uint32(24);
    writer.int64(message.retainHeight);
  }

  static decode(reader: Reader, length: i32): ResponseCommit {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseCommit();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2:
          message.data = reader.bytes();
          break;

        case 3:
          message.retainHeight = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  data: Uint8Array;
  retainHeight: i64;

  constructor(data: Uint8Array = new Uint8Array(0), retainHeight: i64 = 0) {
    this.data = data;
    this.retainHeight = retainHeight;
  }
}

export function encodeResponseCommit(message: ResponseCommit): Uint8Array {
  return Protobuf.encode(message, ResponseCommit.encode);
}

export function decodeResponseCommit(buffer: Uint8Array): ResponseCommit {
  return Protobuf.decode<ResponseCommit>(buffer, ResponseCommit.decode);
}

export class ResponseListSnapshots {
  static encode(message: ResponseListSnapshots, writer: Writer): void {
    const snapshots = message.snapshots;
    for (let i = 0; i < snapshots.length; ++i) {
      writer.uint32(10);
      writer.fork();
      Snapshot.encode(snapshots[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): ResponseListSnapshots {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseListSnapshots();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.snapshots.push(Snapshot.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  snapshots: Array<Snapshot>;

  constructor(snapshots: Array<Snapshot> = []) {
    this.snapshots = snapshots;
  }
}

export function encodeResponseListSnapshots(
  message: ResponseListSnapshots
): Uint8Array {
  return Protobuf.encode(message, ResponseListSnapshots.encode);
}

export function decodeResponseListSnapshots(
  buffer: Uint8Array
): ResponseListSnapshots {
  return Protobuf.decode<ResponseListSnapshots>(
    buffer,
    ResponseListSnapshots.decode
  );
}

@unmanaged
export class ResponseOfferSnapshot {
  static encode(message: ResponseOfferSnapshot, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.result);
  }

  static decode(reader: Reader, length: i32): ResponseOfferSnapshot {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseOfferSnapshot();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = reader.int32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  result: ResponseOfferSnapshot.Result;

  constructor(result: ResponseOfferSnapshot.Result = 0) {
    this.result = result;
  }
}

export function encodeResponseOfferSnapshot(
  message: ResponseOfferSnapshot
): Uint8Array {
  return Protobuf.encode(message, ResponseOfferSnapshot.encode);
}

export function decodeResponseOfferSnapshot(
  buffer: Uint8Array
): ResponseOfferSnapshot {
  return Protobuf.decode<ResponseOfferSnapshot>(
    buffer,
    ResponseOfferSnapshot.decode
  );
}

export namespace ResponseOfferSnapshot {
  export enum Result {
    UNKNOWN = 0,
    ACCEPT = 1,
    ABORT = 2,
    REJECT = 3,
    REJECT_FORMAT = 4,
    REJECT_SENDER = 5,
  }
}

export class ResponseLoadSnapshotChunk {
  static encode(message: ResponseLoadSnapshotChunk, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.chunk);
  }

  static decode(reader: Reader, length: i32): ResponseLoadSnapshotChunk {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseLoadSnapshotChunk();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chunk = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  chunk: Uint8Array;

  constructor(chunk: Uint8Array = new Uint8Array(0)) {
    this.chunk = chunk;
  }
}

export function encodeResponseLoadSnapshotChunk(
  message: ResponseLoadSnapshotChunk
): Uint8Array {
  return Protobuf.encode(message, ResponseLoadSnapshotChunk.encode);
}

export function decodeResponseLoadSnapshotChunk(
  buffer: Uint8Array
): ResponseLoadSnapshotChunk {
  return Protobuf.decode<ResponseLoadSnapshotChunk>(
    buffer,
    ResponseLoadSnapshotChunk.decode
  );
}

export class ResponseApplySnapshotChunk {
  static encode(message: ResponseApplySnapshotChunk, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.result);

    const refetchChunks = message.refetchChunks;
    if (refetchChunks.length !== 0) {
      for (let i = 0; i < refetchChunks.length; ++i) {
        writer.uint32(16);
        writer.uint32(refetchChunks[i]);
      }
    }

    const rejectSenders = message.rejectSenders;
    if (rejectSenders.length !== 0) {
      for (let i = 0; i < rejectSenders.length; ++i) {
        writer.uint32(26);
        writer.string(rejectSenders[i]);
      }
    }
  }

  static decode(reader: Reader, length: i32): ResponseApplySnapshotChunk {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ResponseApplySnapshotChunk();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.result = reader.int32();
          break;

        case 2:
          message.refetchChunks.push(reader.uint32());
          break;

        case 3:
          message.rejectSenders.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  result: ResponseApplySnapshotChunk.Result;
  refetchChunks: Array<u32>;
  rejectSenders: Array<string>;

  constructor(
    result: ResponseApplySnapshotChunk.Result = 0,
    refetchChunks: Array<u32> = [],
    rejectSenders: Array<string> = []
  ) {
    this.result = result;
    this.refetchChunks = refetchChunks;
    this.rejectSenders = rejectSenders;
  }
}

export function encodeResponseApplySnapshotChunk(
  message: ResponseApplySnapshotChunk
): Uint8Array {
  return Protobuf.encode(message, ResponseApplySnapshotChunk.encode);
}

export function decodeResponseApplySnapshotChunk(
  buffer: Uint8Array
): ResponseApplySnapshotChunk {
  return Protobuf.decode<ResponseApplySnapshotChunk>(
    buffer,
    ResponseApplySnapshotChunk.decode
  );
}

export namespace ResponseApplySnapshotChunk {
  export enum Result {
    UNKNOWN = 0,
    ACCEPT = 1,
    ABORT = 2,
    RETRY = 3,
    RETRY_SNAPSHOT = 4,
    REJECT_SNAPSHOT = 5,
  }
}

export class ConsensusParams {
  static encode(message: ConsensusParams, writer: Writer): void {
    const block = message.block;
    if (block !== null) {
      writer.uint32(10);
      writer.fork();
      BlockParams.encode(block, writer);
      writer.ldelim();
    }

    const evidence = message.evidence;
    if (evidence !== null) {
      writer.uint32(18);
      writer.fork();
      types.EvidenceParams.encode(evidence, writer);
      writer.ldelim();
    }

    const validator = message.validator;
    if (validator !== null) {
      writer.uint32(26);
      writer.fork();
      types.ValidatorParams.encode(validator, writer);
      writer.ldelim();
    }

    const version = message.version;
    if (version !== null) {
      writer.uint32(34);
      writer.fork();
      types.VersionParams.encode(version, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): ConsensusParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ConsensusParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.block = BlockParams.decode(reader, reader.uint32());
          break;

        case 2:
          message.evidence = types.EvidenceParams.decode(
            reader,
            reader.uint32()
          );
          break;

        case 3:
          message.validator = types.ValidatorParams.decode(
            reader,
            reader.uint32()
          );
          break;

        case 4:
          message.version = types.VersionParams.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  block: BlockParams | null;
  evidence: types.EvidenceParams | null;
  validator: types.ValidatorParams | null;
  version: types.VersionParams | null;

  constructor(
    block: BlockParams | null = null,
    evidence: types.EvidenceParams | null = null,
    validator: types.ValidatorParams | null = null,
    version: types.VersionParams | null = null
  ) {
    this.block = block;
    this.evidence = evidence;
    this.validator = validator;
    this.version = version;
  }
}

export function encodeConsensusParams(message: ConsensusParams): Uint8Array {
  return Protobuf.encode(message, ConsensusParams.encode);
}

export function decodeConsensusParams(buffer: Uint8Array): ConsensusParams {
  return Protobuf.decode<ConsensusParams>(buffer, ConsensusParams.decode);
}

@unmanaged
export class BlockParams {
  static encode(message: BlockParams, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.maxBytes);

    writer.uint32(16);
    writer.int64(message.maxGas);
  }

  static decode(reader: Reader, length: i32): BlockParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new BlockParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.maxBytes = reader.int64();
          break;

        case 2:
          message.maxGas = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  maxBytes: i64;
  maxGas: i64;

  constructor(maxBytes: i64 = 0, maxGas: i64 = 0) {
    this.maxBytes = maxBytes;
    this.maxGas = maxGas;
  }
}

export function encodeBlockParams(message: BlockParams): Uint8Array {
  return Protobuf.encode(message, BlockParams.encode);
}

export function decodeBlockParams(buffer: Uint8Array): BlockParams {
  return Protobuf.decode<BlockParams>(buffer, BlockParams.decode);
}

export class LastCommitInfo {
  static encode(message: LastCommitInfo, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.round);

    const votes = message.votes;
    for (let i = 0; i < votes.length; ++i) {
      writer.uint32(18);
      writer.fork();
      VoteInfo.encode(votes[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): LastCommitInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new LastCommitInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.round = reader.int32();
          break;

        case 2:
          message.votes.push(VoteInfo.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  round: i32;
  votes: Array<VoteInfo>;

  constructor(round: i32 = 0, votes: Array<VoteInfo> = []) {
    this.round = round;
    this.votes = votes;
  }
}

export function encodeLastCommitInfo(message: LastCommitInfo): Uint8Array {
  return Protobuf.encode(message, LastCommitInfo.encode);
}

export function decodeLastCommitInfo(buffer: Uint8Array): LastCommitInfo {
  return Protobuf.decode<LastCommitInfo>(buffer, LastCommitInfo.decode);
}

export class Event {
  static encode(message: Event, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.type);

    const attributes = message.attributes;
    for (let i = 0; i < attributes.length; ++i) {
      writer.uint32(18);
      writer.fork();
      EventAttribute.encode(attributes[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Event {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Event();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;

        case 2:
          message.attributes.push(
            EventAttribute.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  type: string;
  attributes: Array<EventAttribute>;

  constructor(type: string = "", attributes: Array<EventAttribute> = []) {
    this.type = type;
    this.attributes = attributes;
  }
}

export function encodeEvent(message: Event): Uint8Array {
  return Protobuf.encode(message, Event.encode);
}

export function decodeEvent(buffer: Uint8Array): Event {
  return Protobuf.decode<Event>(buffer, Event.decode);
}

export class EventAttribute {
  static encode(message: EventAttribute, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.key);

    writer.uint32(18);
    writer.bytes(message.value);

    writer.uint32(24);
    writer.bool(message.index);
  }

  static decode(reader: Reader, length: i32): EventAttribute {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new EventAttribute();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;

        case 2:
          message.value = reader.bytes();
          break;

        case 3:
          message.index = reader.bool();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  key: Uint8Array;
  value: Uint8Array;
  index: bool;

  constructor(
    key: Uint8Array = new Uint8Array(0),
    value: Uint8Array = new Uint8Array(0),
    index: bool = false
  ) {
    this.key = key;
    this.value = value;
    this.index = index;
  }
}

export function encodeEventAttribute(message: EventAttribute): Uint8Array {
  return Protobuf.encode(message, EventAttribute.encode);
}

export function decodeEventAttribute(buffer: Uint8Array): EventAttribute {
  return Protobuf.decode<EventAttribute>(buffer, EventAttribute.decode);
}

export class TxResult {
  static encode(message: TxResult, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.height);

    writer.uint32(16);
    writer.uint32(message.index);

    writer.uint32(26);
    writer.bytes(message.tx);

    const result = message.result;
    if (result !== null) {
      writer.uint32(34);
      writer.fork();
      ResponseDeliverTx.encode(result, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): TxResult {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new TxResult();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = reader.int64();
          break;

        case 2:
          message.index = reader.uint32();
          break;

        case 3:
          message.tx = reader.bytes();
          break;

        case 4:
          message.result = ResponseDeliverTx.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  height: i64;
  index: u32;
  tx: Uint8Array;
  result: ResponseDeliverTx | null;

  constructor(
    height: i64 = 0,
    index: u32 = 0,
    tx: Uint8Array = new Uint8Array(0),
    result: ResponseDeliverTx | null = null
  ) {
    this.height = height;
    this.index = index;
    this.tx = tx;
    this.result = result;
  }
}

export function encodeTxResult(message: TxResult): Uint8Array {
  return Protobuf.encode(message, TxResult.encode);
}

export function decodeTxResult(buffer: Uint8Array): TxResult {
  return Protobuf.decode<TxResult>(buffer, TxResult.decode);
}

export class Validator {
  static encode(message: Validator, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.address);

    writer.uint32(24);
    writer.int64(message.power);
  }

  static decode(reader: Reader, length: i32): Validator {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Validator();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.address = reader.bytes();
          break;

        case 3:
          message.power = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  address: Uint8Array;
  power: i64;

  constructor(address: Uint8Array = new Uint8Array(0), power: i64 = 0) {
    this.address = address;
    this.power = power;
  }
}

export function encodeValidator(message: Validator): Uint8Array {
  return Protobuf.encode(message, Validator.encode);
}

export function decodeValidator(buffer: Uint8Array): Validator {
  return Protobuf.decode<Validator>(buffer, Validator.decode);
}

export class ValidatorUpdate {
  static encode(message: ValidatorUpdate, writer: Writer): void {
    const pubKey = message.pubKey;
    if (pubKey !== null) {
      writer.uint32(10);
      writer.fork();
      crypto.PublicKey.encode(pubKey, writer);
      writer.ldelim();
    }

    writer.uint32(16);
    writer.int64(message.power);
  }

  static decode(reader: Reader, length: i32): ValidatorUpdate {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ValidatorUpdate();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pubKey = crypto.PublicKey.decode(reader, reader.uint32());
          break;

        case 2:
          message.power = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  pubKey: crypto.PublicKey | null;
  power: i64;

  constructor(pubKey: crypto.PublicKey | null = null, power: i64 = 0) {
    this.pubKey = pubKey;
    this.power = power;
  }
}

export function encodeValidatorUpdate(message: ValidatorUpdate): Uint8Array {
  return Protobuf.encode(message, ValidatorUpdate.encode);
}

export function decodeValidatorUpdate(buffer: Uint8Array): ValidatorUpdate {
  return Protobuf.decode<ValidatorUpdate>(buffer, ValidatorUpdate.decode);
}

export class VoteInfo {
  static encode(message: VoteInfo, writer: Writer): void {
    const validator = message.validator;
    if (validator !== null) {
      writer.uint32(10);
      writer.fork();
      Validator.encode(validator, writer);
      writer.ldelim();
    }

    writer.uint32(16);
    writer.bool(message.signedLastBlock);
  }

  static decode(reader: Reader, length: i32): VoteInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new VoteInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.validator = Validator.decode(reader, reader.uint32());
          break;

        case 2:
          message.signedLastBlock = reader.bool();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  validator: Validator | null;
  signedLastBlock: bool;

  constructor(
    validator: Validator | null = null,
    signedLastBlock: bool = false
  ) {
    this.validator = validator;
    this.signedLastBlock = signedLastBlock;
  }
}

export function encodeVoteInfo(message: VoteInfo): Uint8Array {
  return Protobuf.encode(message, VoteInfo.encode);
}

export function decodeVoteInfo(buffer: Uint8Array): VoteInfo {
  return Protobuf.decode<VoteInfo>(buffer, VoteInfo.decode);
}

export class Evidence {
  static encode(message: Evidence, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.type);

    const validator = message.validator;
    if (validator !== null) {
      writer.uint32(18);
      writer.fork();
      Validator.encode(validator, writer);
      writer.ldelim();
    }

    writer.uint32(24);
    writer.int64(message.height);

    const time = message.time;
    if (time !== null) {
      writer.uint32(34);
      writer.fork();
      google.protobuf.Timestamp.encode(time, writer);
      writer.ldelim();
    }

    writer.uint32(40);
    writer.int64(message.totalVotingPower);
  }

  static decode(reader: Reader, length: i32): Evidence {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Evidence();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.int32();
          break;

        case 2:
          message.validator = Validator.decode(reader, reader.uint32());
          break;

        case 3:
          message.height = reader.int64();
          break;

        case 4:
          message.time = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 5:
          message.totalVotingPower = reader.int64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  type: EvidenceType;
  validator: Validator | null;
  height: i64;
  time: google.protobuf.Timestamp | null;
  totalVotingPower: i64;

  constructor(
    type: EvidenceType = 0,
    validator: Validator | null = null,
    height: i64 = 0,
    time: google.protobuf.Timestamp | null = null,
    totalVotingPower: i64 = 0
  ) {
    this.type = type;
    this.validator = validator;
    this.height = height;
    this.time = time;
    this.totalVotingPower = totalVotingPower;
  }
}

export function encodeEvidence(message: Evidence): Uint8Array {
  return Protobuf.encode(message, Evidence.encode);
}

export function decodeEvidence(buffer: Uint8Array): Evidence {
  return Protobuf.decode<Evidence>(buffer, Evidence.decode);
}

export class Snapshot {
  static encode(message: Snapshot, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.height);

    writer.uint32(16);
    writer.uint32(message.format);

    writer.uint32(24);
    writer.uint32(message.chunks);

    writer.uint32(34);
    writer.bytes(message.hash);

    writer.uint32(42);
    writer.bytes(message.metadata);
  }

  static decode(reader: Reader, length: i32): Snapshot {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Snapshot();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = reader.uint64();
          break;

        case 2:
          message.format = reader.uint32();
          break;

        case 3:
          message.chunks = reader.uint32();
          break;

        case 4:
          message.hash = reader.bytes();
          break;

        case 5:
          message.metadata = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  height: u64;
  format: u32;
  chunks: u32;
  hash: Uint8Array;
  metadata: Uint8Array;

  constructor(
    height: u64 = 0,
    format: u32 = 0,
    chunks: u32 = 0,
    hash: Uint8Array = new Uint8Array(0),
    metadata: Uint8Array = new Uint8Array(0)
  ) {
    this.height = height;
    this.format = format;
    this.chunks = chunks;
    this.hash = hash;
    this.metadata = metadata;
  }
}

export function encodeSnapshot(message: Snapshot): Uint8Array {
  return Protobuf.encode(message, Snapshot.encode);
}

export function decodeSnapshot(buffer: Uint8Array): Snapshot {
  return Protobuf.decode<Snapshot>(buffer, Snapshot.decode);
}

export enum CheckTxType {
  NEW = 0,
  RECHECK = 1,
}

export enum EvidenceType {
  UNKNOWN = 0,
  DUPLICATE_VOTE = 1,
  LIGHT_CLIENT_ATTACK = 2,
}
