// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.4.0
//   protoc        v3.21.6

import { Writer, Reader, Protobuf } from "as-proto";

export class ExistenceProof {
  static encode(message: ExistenceProof, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.key);

    writer.uint32(18);
    writer.bytes(message.value);

    const leaf = message.leaf;
    if (leaf !== null) {
      writer.uint32(26);
      writer.fork();
      LeafOp.encode(leaf, writer);
      writer.ldelim();
    }

    const path = message.path;
    for (let i = 0; i < path.length; ++i) {
      writer.uint32(34);
      writer.fork();
      InnerOp.encode(path[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): ExistenceProof {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ExistenceProof();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;

        case 2:
          message.value = reader.bytes();
          break;

        case 3:
          message.leaf = LeafOp.decode(reader, reader.uint32());
          break;

        case 4:
          message.path.push(InnerOp.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  key: Uint8Array;
  value: Uint8Array;
  leaf: LeafOp | null;
  path: Array<InnerOp>;

  constructor(
    key: Uint8Array = new Uint8Array(0),
    value: Uint8Array = new Uint8Array(0),
    leaf: LeafOp | null = null,
    path: Array<InnerOp> = []
  ) {
    this.key = key;
    this.value = value;
    this.leaf = leaf;
    this.path = path;
  }
}

export function encodeExistenceProof(message: ExistenceProof): Uint8Array {
  return Protobuf.encode(message, ExistenceProof.encode);
}

export function decodeExistenceProof(buffer: Uint8Array): ExistenceProof {
  return Protobuf.decode<ExistenceProof>(buffer, ExistenceProof.decode);
}

export class NonExistenceProof {
  static encode(message: NonExistenceProof, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.key);

    const left = message.left;
    if (left !== null) {
      writer.uint32(18);
      writer.fork();
      ExistenceProof.encode(left, writer);
      writer.ldelim();
    }

    const right = message.right;
    if (right !== null) {
      writer.uint32(26);
      writer.fork();
      ExistenceProof.encode(right, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): NonExistenceProof {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new NonExistenceProof();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;

        case 2:
          message.left = ExistenceProof.decode(reader, reader.uint32());
          break;

        case 3:
          message.right = ExistenceProof.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  key: Uint8Array;
  left: ExistenceProof | null;
  right: ExistenceProof | null;

  constructor(
    key: Uint8Array = new Uint8Array(0),
    left: ExistenceProof | null = null,
    right: ExistenceProof | null = null
  ) {
    this.key = key;
    this.left = left;
    this.right = right;
  }
}

export function encodeNonExistenceProof(
  message: NonExistenceProof
): Uint8Array {
  return Protobuf.encode(message, NonExistenceProof.encode);
}

export function decodeNonExistenceProof(buffer: Uint8Array): NonExistenceProof {
  return Protobuf.decode<NonExistenceProof>(buffer, NonExistenceProof.decode);
}

export class CommitmentProof {
  static encode(message: CommitmentProof, writer: Writer): void {
    const exist = message.exist;
    if (exist !== null) {
      writer.uint32(10);
      writer.fork();
      ExistenceProof.encode(exist, writer);
      writer.ldelim();
    }

    const nonexist = message.nonexist;
    if (nonexist !== null) {
      writer.uint32(18);
      writer.fork();
      NonExistenceProof.encode(nonexist, writer);
      writer.ldelim();
    }

    const batch = message.batch;
    if (batch !== null) {
      writer.uint32(26);
      writer.fork();
      BatchProof.encode(batch, writer);
      writer.ldelim();
    }

    const compressed = message.compressed;
    if (compressed !== null) {
      writer.uint32(34);
      writer.fork();
      CompressedBatchProof.encode(compressed, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): CommitmentProof {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CommitmentProof();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.exist = ExistenceProof.decode(reader, reader.uint32());
          break;

        case 2:
          message.nonexist = NonExistenceProof.decode(reader, reader.uint32());
          break;

        case 3:
          message.batch = BatchProof.decode(reader, reader.uint32());
          break;

        case 4:
          message.compressed = CompressedBatchProof.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  exist: ExistenceProof | null;
  nonexist: NonExistenceProof | null;
  batch: BatchProof | null;
  compressed: CompressedBatchProof | null;

  constructor(
    exist: ExistenceProof | null = null,
    nonexist: NonExistenceProof | null = null,
    batch: BatchProof | null = null,
    compressed: CompressedBatchProof | null = null
  ) {
    this.exist = exist;
    this.nonexist = nonexist;
    this.batch = batch;
    this.compressed = compressed;
  }
}

export function encodeCommitmentProof(message: CommitmentProof): Uint8Array {
  return Protobuf.encode(message, CommitmentProof.encode);
}

export function decodeCommitmentProof(buffer: Uint8Array): CommitmentProof {
  return Protobuf.decode<CommitmentProof>(buffer, CommitmentProof.decode);
}

export class LeafOp {
  static encode(message: LeafOp, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.hash);

    writer.uint32(16);
    writer.int32(message.prehashKey);

    writer.uint32(24);
    writer.int32(message.prehashValue);

    writer.uint32(32);
    writer.int32(message.length);

    writer.uint32(42);
    writer.bytes(message.prefix);
  }

  static decode(reader: Reader, length: i32): LeafOp {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new LeafOp();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader.int32();
          break;

        case 2:
          message.prehashKey = reader.int32();
          break;

        case 3:
          message.prehashValue = reader.int32();
          break;

        case 4:
          message.length = reader.int32();
          break;

        case 5:
          message.prefix = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  hash: HashOp;
  prehashKey: HashOp;
  prehashValue: HashOp;
  length: LengthOp;
  prefix: Uint8Array;

  constructor(
    hash: HashOp = 0,
    prehashKey: HashOp = 0,
    prehashValue: HashOp = 0,
    length: LengthOp = 0,
    prefix: Uint8Array = new Uint8Array(0)
  ) {
    this.hash = hash;
    this.prehashKey = prehashKey;
    this.prehashValue = prehashValue;
    this.length = length;
    this.prefix = prefix;
  }
}

export function encodeLeafOp(message: LeafOp): Uint8Array {
  return Protobuf.encode(message, LeafOp.encode);
}

export function decodeLeafOp(buffer: Uint8Array): LeafOp {
  return Protobuf.decode<LeafOp>(buffer, LeafOp.decode);
}

export class InnerOp {
  static encode(message: InnerOp, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.hash);

    writer.uint32(18);
    writer.bytes(message.prefix);

    writer.uint32(26);
    writer.bytes(message.suffix);
  }

  static decode(reader: Reader, length: i32): InnerOp {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new InnerOp();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.hash = reader.int32();
          break;

        case 2:
          message.prefix = reader.bytes();
          break;

        case 3:
          message.suffix = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  hash: HashOp;
  prefix: Uint8Array;
  suffix: Uint8Array;

  constructor(
    hash: HashOp = 0,
    prefix: Uint8Array = new Uint8Array(0),
    suffix: Uint8Array = new Uint8Array(0)
  ) {
    this.hash = hash;
    this.prefix = prefix;
    this.suffix = suffix;
  }
}

export function encodeInnerOp(message: InnerOp): Uint8Array {
  return Protobuf.encode(message, InnerOp.encode);
}

export function decodeInnerOp(buffer: Uint8Array): InnerOp {
  return Protobuf.decode<InnerOp>(buffer, InnerOp.decode);
}

export class ProofSpec {
  static encode(message: ProofSpec, writer: Writer): void {
    const leafSpec = message.leafSpec;
    if (leafSpec !== null) {
      writer.uint32(10);
      writer.fork();
      LeafOp.encode(leafSpec, writer);
      writer.ldelim();
    }

    const innerSpec = message.innerSpec;
    if (innerSpec !== null) {
      writer.uint32(18);
      writer.fork();
      InnerSpec.encode(innerSpec, writer);
      writer.ldelim();
    }

    writer.uint32(24);
    writer.int32(message.maxDepth);

    writer.uint32(32);
    writer.int32(message.minDepth);
  }

  static decode(reader: Reader, length: i32): ProofSpec {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ProofSpec();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.leafSpec = LeafOp.decode(reader, reader.uint32());
          break;

        case 2:
          message.innerSpec = InnerSpec.decode(reader, reader.uint32());
          break;

        case 3:
          message.maxDepth = reader.int32();
          break;

        case 4:
          message.minDepth = reader.int32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  leafSpec: LeafOp | null;
  innerSpec: InnerSpec | null;
  maxDepth: i32;
  minDepth: i32;

  constructor(
    leafSpec: LeafOp | null = null,
    innerSpec: InnerSpec | null = null,
    maxDepth: i32 = 0,
    minDepth: i32 = 0
  ) {
    this.leafSpec = leafSpec;
    this.innerSpec = innerSpec;
    this.maxDepth = maxDepth;
    this.minDepth = minDepth;
  }
}

export function encodeProofSpec(message: ProofSpec): Uint8Array {
  return Protobuf.encode(message, ProofSpec.encode);
}

export function decodeProofSpec(buffer: Uint8Array): ProofSpec {
  return Protobuf.decode<ProofSpec>(buffer, ProofSpec.decode);
}

export class InnerSpec {
  static encode(message: InnerSpec, writer: Writer): void {
    const childOrder = message.childOrder;
    if (childOrder.length !== 0) {
      for (let i = 0; i < childOrder.length; ++i) {
        writer.uint32(8);
        writer.int32(childOrder[i]);
      }
    }

    writer.uint32(16);
    writer.int32(message.childSize);

    writer.uint32(24);
    writer.int32(message.minPrefixLength);

    writer.uint32(32);
    writer.int32(message.maxPrefixLength);

    writer.uint32(42);
    writer.bytes(message.emptyChild);

    writer.uint32(48);
    writer.int32(message.hash);
  }

  static decode(reader: Reader, length: i32): InnerSpec {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new InnerSpec();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.childOrder.push(reader.int32());
          break;

        case 2:
          message.childSize = reader.int32();
          break;

        case 3:
          message.minPrefixLength = reader.int32();
          break;

        case 4:
          message.maxPrefixLength = reader.int32();
          break;

        case 5:
          message.emptyChild = reader.bytes();
          break;

        case 6:
          message.hash = reader.int32();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  childOrder: Array<i32>;
  childSize: i32;
  minPrefixLength: i32;
  maxPrefixLength: i32;
  emptyChild: Uint8Array;
  hash: HashOp;

  constructor(
    childOrder: Array<i32> = [],
    childSize: i32 = 0,
    minPrefixLength: i32 = 0,
    maxPrefixLength: i32 = 0,
    emptyChild: Uint8Array = new Uint8Array(0),
    hash: HashOp = 0
  ) {
    this.childOrder = childOrder;
    this.childSize = childSize;
    this.minPrefixLength = minPrefixLength;
    this.maxPrefixLength = maxPrefixLength;
    this.emptyChild = emptyChild;
    this.hash = hash;
  }
}

export function encodeInnerSpec(message: InnerSpec): Uint8Array {
  return Protobuf.encode(message, InnerSpec.encode);
}

export function decodeInnerSpec(buffer: Uint8Array): InnerSpec {
  return Protobuf.decode<InnerSpec>(buffer, InnerSpec.decode);
}

export class BatchProof {
  static encode(message: BatchProof, writer: Writer): void {
    const entries = message.entries;
    for (let i = 0; i < entries.length; ++i) {
      writer.uint32(10);
      writer.fork();
      BatchEntry.encode(entries[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): BatchProof {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new BatchProof();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entries.push(BatchEntry.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  entries: Array<BatchEntry>;

  constructor(entries: Array<BatchEntry> = []) {
    this.entries = entries;
  }
}

export function encodeBatchProof(message: BatchProof): Uint8Array {
  return Protobuf.encode(message, BatchProof.encode);
}

export function decodeBatchProof(buffer: Uint8Array): BatchProof {
  return Protobuf.decode<BatchProof>(buffer, BatchProof.decode);
}

export class BatchEntry {
  static encode(message: BatchEntry, writer: Writer): void {
    const exist = message.exist;
    if (exist !== null) {
      writer.uint32(10);
      writer.fork();
      ExistenceProof.encode(exist, writer);
      writer.ldelim();
    }

    const nonexist = message.nonexist;
    if (nonexist !== null) {
      writer.uint32(18);
      writer.fork();
      NonExistenceProof.encode(nonexist, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): BatchEntry {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new BatchEntry();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.exist = ExistenceProof.decode(reader, reader.uint32());
          break;

        case 2:
          message.nonexist = NonExistenceProof.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  exist: ExistenceProof | null;
  nonexist: NonExistenceProof | null;

  constructor(
    exist: ExistenceProof | null = null,
    nonexist: NonExistenceProof | null = null
  ) {
    this.exist = exist;
    this.nonexist = nonexist;
  }
}

export function encodeBatchEntry(message: BatchEntry): Uint8Array {
  return Protobuf.encode(message, BatchEntry.encode);
}

export function decodeBatchEntry(buffer: Uint8Array): BatchEntry {
  return Protobuf.decode<BatchEntry>(buffer, BatchEntry.decode);
}

export class CompressedBatchProof {
  static encode(message: CompressedBatchProof, writer: Writer): void {
    const entries = message.entries;
    for (let i = 0; i < entries.length; ++i) {
      writer.uint32(10);
      writer.fork();
      CompressedBatchEntry.encode(entries[i], writer);
      writer.ldelim();
    }

    const lookupInners = message.lookupInners;
    for (let i = 0; i < lookupInners.length; ++i) {
      writer.uint32(18);
      writer.fork();
      InnerOp.encode(lookupInners[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): CompressedBatchProof {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CompressedBatchProof();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.entries.push(
            CompressedBatchEntry.decode(reader, reader.uint32())
          );
          break;

        case 2:
          message.lookupInners.push(InnerOp.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  entries: Array<CompressedBatchEntry>;
  lookupInners: Array<InnerOp>;

  constructor(
    entries: Array<CompressedBatchEntry> = [],
    lookupInners: Array<InnerOp> = []
  ) {
    this.entries = entries;
    this.lookupInners = lookupInners;
  }
}

export function encodeCompressedBatchProof(
  message: CompressedBatchProof
): Uint8Array {
  return Protobuf.encode(message, CompressedBatchProof.encode);
}

export function decodeCompressedBatchProof(
  buffer: Uint8Array
): CompressedBatchProof {
  return Protobuf.decode<CompressedBatchProof>(
    buffer,
    CompressedBatchProof.decode
  );
}

export class CompressedBatchEntry {
  static encode(message: CompressedBatchEntry, writer: Writer): void {
    const exist = message.exist;
    if (exist !== null) {
      writer.uint32(10);
      writer.fork();
      CompressedExistenceProof.encode(exist, writer);
      writer.ldelim();
    }

    const nonexist = message.nonexist;
    if (nonexist !== null) {
      writer.uint32(18);
      writer.fork();
      CompressedNonExistenceProof.encode(nonexist, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): CompressedBatchEntry {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CompressedBatchEntry();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.exist = CompressedExistenceProof.decode(
            reader,
            reader.uint32()
          );
          break;

        case 2:
          message.nonexist = CompressedNonExistenceProof.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  exist: CompressedExistenceProof | null;
  nonexist: CompressedNonExistenceProof | null;

  constructor(
    exist: CompressedExistenceProof | null = null,
    nonexist: CompressedNonExistenceProof | null = null
  ) {
    this.exist = exist;
    this.nonexist = nonexist;
  }
}

export function encodeCompressedBatchEntry(
  message: CompressedBatchEntry
): Uint8Array {
  return Protobuf.encode(message, CompressedBatchEntry.encode);
}

export function decodeCompressedBatchEntry(
  buffer: Uint8Array
): CompressedBatchEntry {
  return Protobuf.decode<CompressedBatchEntry>(
    buffer,
    CompressedBatchEntry.decode
  );
}

export class CompressedExistenceProof {
  static encode(message: CompressedExistenceProof, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.key);

    writer.uint32(18);
    writer.bytes(message.value);

    const leaf = message.leaf;
    if (leaf !== null) {
      writer.uint32(26);
      writer.fork();
      LeafOp.encode(leaf, writer);
      writer.ldelim();
    }

    const path = message.path;
    if (path.length !== 0) {
      for (let i = 0; i < path.length; ++i) {
        writer.uint32(32);
        writer.int32(path[i]);
      }
    }
  }

  static decode(reader: Reader, length: i32): CompressedExistenceProof {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CompressedExistenceProof();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;

        case 2:
          message.value = reader.bytes();
          break;

        case 3:
          message.leaf = LeafOp.decode(reader, reader.uint32());
          break;

        case 4:
          message.path.push(reader.int32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  key: Uint8Array;
  value: Uint8Array;
  leaf: LeafOp | null;
  path: Array<i32>;

  constructor(
    key: Uint8Array = new Uint8Array(0),
    value: Uint8Array = new Uint8Array(0),
    leaf: LeafOp | null = null,
    path: Array<i32> = []
  ) {
    this.key = key;
    this.value = value;
    this.leaf = leaf;
    this.path = path;
  }
}

export function encodeCompressedExistenceProof(
  message: CompressedExistenceProof
): Uint8Array {
  return Protobuf.encode(message, CompressedExistenceProof.encode);
}

export function decodeCompressedExistenceProof(
  buffer: Uint8Array
): CompressedExistenceProof {
  return Protobuf.decode<CompressedExistenceProof>(
    buffer,
    CompressedExistenceProof.decode
  );
}

export class CompressedNonExistenceProof {
  static encode(message: CompressedNonExistenceProof, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.key);

    const left = message.left;
    if (left !== null) {
      writer.uint32(18);
      writer.fork();
      CompressedExistenceProof.encode(left, writer);
      writer.ldelim();
    }

    const right = message.right;
    if (right !== null) {
      writer.uint32(26);
      writer.fork();
      CompressedExistenceProof.encode(right, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): CompressedNonExistenceProof {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CompressedNonExistenceProof();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.bytes();
          break;

        case 2:
          message.left = CompressedExistenceProof.decode(
            reader,
            reader.uint32()
          );
          break;

        case 3:
          message.right = CompressedExistenceProof.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  key: Uint8Array;
  left: CompressedExistenceProof | null;
  right: CompressedExistenceProof | null;

  constructor(
    key: Uint8Array = new Uint8Array(0),
    left: CompressedExistenceProof | null = null,
    right: CompressedExistenceProof | null = null
  ) {
    this.key = key;
    this.left = left;
    this.right = right;
  }
}

export function encodeCompressedNonExistenceProof(
  message: CompressedNonExistenceProof
): Uint8Array {
  return Protobuf.encode(message, CompressedNonExistenceProof.encode);
}

export function decodeCompressedNonExistenceProof(
  buffer: Uint8Array
): CompressedNonExistenceProof {
  return Protobuf.decode<CompressedNonExistenceProof>(
    buffer,
    CompressedNonExistenceProof.decode
  );
}

export enum HashOp {
  NO_HASH = 0,
  SHA256 = 1,
  SHA512 = 2,
  KECCAK = 3,
  RIPEMD160 = 4,
  BITCOIN = 5,
}

export enum LengthOp {
  NO_PREFIX = 0,
  VAR_PROTO = 1,
  VAR_RLP = 2,
  FIXED32_BIG = 3,
  FIXED32_LITTLE = 4,
  FIXED64_BIG = 5,
  FIXED64_LITTLE = 6,
  REQUIRE_32_BYTES = 7,
  REQUIRE_64_BYTES = 8,
}
