// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.4.0
//   protoc        v3.21.7

import { Writer, Reader, Protobuf } from "as-proto";
import { base } from "../../base";
import { google } from "../../../google";

export class WeightedVoteOption {
  static encode(message: WeightedVoteOption, writer: Writer): void {
    writer.uint32(8);
    writer.int32(message.option);

    writer.uint32(18);
    writer.string(message.weight);
  }

  static decode(reader: Reader, length: i32): WeightedVoteOption {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new WeightedVoteOption();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.option = reader.int32();
          break;

        case 2:
          message.weight = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  option: VoteOption;
  weight: string;

  constructor(option: VoteOption = 0, weight: string = "") {
    this.option = option;
    this.weight = weight;
  }
}

export function encodeWeightedVoteOption(
  message: WeightedVoteOption
): Uint8Array {
  return Protobuf.encode(message, WeightedVoteOption.encode);
}

export function decodeWeightedVoteOption(
  buffer: Uint8Array
): WeightedVoteOption {
  return Protobuf.decode<WeightedVoteOption>(buffer, WeightedVoteOption.decode);
}

export class TextProposal {
  static encode(message: TextProposal, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.title);

    writer.uint32(18);
    writer.string(message.description);
  }

  static decode(reader: Reader, length: i32): TextProposal {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new TextProposal();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.title = reader.string();
          break;

        case 2:
          message.description = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  title: string;
  description: string;

  constructor(title: string = "", description: string = "") {
    this.title = title;
    this.description = description;
  }
}

export function encodeTextProposal(message: TextProposal): Uint8Array {
  return Protobuf.encode(message, TextProposal.encode);
}

export function decodeTextProposal(buffer: Uint8Array): TextProposal {
  return Protobuf.decode<TextProposal>(buffer, TextProposal.decode);
}

export class Deposit {
  static encode(message: Deposit, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.proposalId);

    writer.uint32(18);
    writer.string(message.depositor);

    const amount = message.amount;
    for (let i = 0; i < amount.length; ++i) {
      writer.uint32(26);
      writer.fork();
      base.v1beta1.Coin.encode(amount[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Deposit {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Deposit();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.proposalId = reader.uint64();
          break;

        case 2:
          message.depositor = reader.string();
          break;

        case 3:
          message.amount.push(
            base.v1beta1.Coin.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  proposalId: u64;
  depositor: string;
  amount: Array<base.v1beta1.Coin>;

  constructor(
    proposalId: u64 = 0,
    depositor: string = "",
    amount: Array<base.v1beta1.Coin> = []
  ) {
    this.proposalId = proposalId;
    this.depositor = depositor;
    this.amount = amount;
  }
}

export function encodeDeposit(message: Deposit): Uint8Array {
  return Protobuf.encode(message, Deposit.encode);
}

export function decodeDeposit(buffer: Uint8Array): Deposit {
  return Protobuf.decode<Deposit>(buffer, Deposit.decode);
}

export class Proposal {
  static encode(message: Proposal, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.proposalId);

    const content = message.content;
    if (content !== null) {
      writer.uint32(18);
      writer.fork();
      google.protobuf.Any.encode(content, writer);
      writer.ldelim();
    }

    writer.uint32(24);
    writer.int32(message.status);

    const finalTallyResult = message.finalTallyResult;
    if (finalTallyResult !== null) {
      writer.uint32(34);
      writer.fork();
      TallyResult.encode(finalTallyResult, writer);
      writer.ldelim();
    }

    const submitTime = message.submitTime;
    if (submitTime !== null) {
      writer.uint32(42);
      writer.fork();
      google.protobuf.Timestamp.encode(submitTime, writer);
      writer.ldelim();
    }

    const depositEndTime = message.depositEndTime;
    if (depositEndTime !== null) {
      writer.uint32(50);
      writer.fork();
      google.protobuf.Timestamp.encode(depositEndTime, writer);
      writer.ldelim();
    }

    const totalDeposit = message.totalDeposit;
    for (let i = 0; i < totalDeposit.length; ++i) {
      writer.uint32(58);
      writer.fork();
      base.v1beta1.Coin.encode(totalDeposit[i], writer);
      writer.ldelim();
    }

    const votingStartTime = message.votingStartTime;
    if (votingStartTime !== null) {
      writer.uint32(66);
      writer.fork();
      google.protobuf.Timestamp.encode(votingStartTime, writer);
      writer.ldelim();
    }

    const votingEndTime = message.votingEndTime;
    if (votingEndTime !== null) {
      writer.uint32(74);
      writer.fork();
      google.protobuf.Timestamp.encode(votingEndTime, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Proposal {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Proposal();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.proposalId = reader.uint64();
          break;

        case 2:
          message.content = google.protobuf.Any.decode(reader, reader.uint32());
          break;

        case 3:
          message.status = reader.int32();
          break;

        case 4:
          message.finalTallyResult = TallyResult.decode(
            reader,
            reader.uint32()
          );
          break;

        case 5:
          message.submitTime = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 6:
          message.depositEndTime = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 7:
          message.totalDeposit.push(
            base.v1beta1.Coin.decode(reader, reader.uint32())
          );
          break;

        case 8:
          message.votingStartTime = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 9:
          message.votingEndTime = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  proposalId: u64;
  content: google.protobuf.Any | null;
  status: ProposalStatus;
  finalTallyResult: TallyResult | null;
  submitTime: google.protobuf.Timestamp | null;
  depositEndTime: google.protobuf.Timestamp | null;
  totalDeposit: Array<base.v1beta1.Coin>;
  votingStartTime: google.protobuf.Timestamp | null;
  votingEndTime: google.protobuf.Timestamp | null;

  constructor(
    proposalId: u64 = 0,
    content: google.protobuf.Any | null = null,
    status: ProposalStatus = 0,
    finalTallyResult: TallyResult | null = null,
    submitTime: google.protobuf.Timestamp | null = null,
    depositEndTime: google.protobuf.Timestamp | null = null,
    totalDeposit: Array<base.v1beta1.Coin> = [],
    votingStartTime: google.protobuf.Timestamp | null = null,
    votingEndTime: google.protobuf.Timestamp | null = null
  ) {
    this.proposalId = proposalId;
    this.content = content;
    this.status = status;
    this.finalTallyResult = finalTallyResult;
    this.submitTime = submitTime;
    this.depositEndTime = depositEndTime;
    this.totalDeposit = totalDeposit;
    this.votingStartTime = votingStartTime;
    this.votingEndTime = votingEndTime;
  }
}

export function encodeProposal(message: Proposal): Uint8Array {
  return Protobuf.encode(message, Proposal.encode);
}

export function decodeProposal(buffer: Uint8Array): Proposal {
  return Protobuf.decode<Proposal>(buffer, Proposal.decode);
}

export class TallyResult {
  static encode(message: TallyResult, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.yes);

    writer.uint32(18);
    writer.string(message.abstain);

    writer.uint32(26);
    writer.string(message.no);

    writer.uint32(34);
    writer.string(message.noWithVeto);
  }

  static decode(reader: Reader, length: i32): TallyResult {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new TallyResult();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.yes = reader.string();
          break;

        case 2:
          message.abstain = reader.string();
          break;

        case 3:
          message.no = reader.string();
          break;

        case 4:
          message.noWithVeto = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  yes: string;
  abstain: string;
  no: string;
  noWithVeto: string;

  constructor(
    yes: string = "",
    abstain: string = "",
    no: string = "",
    noWithVeto: string = ""
  ) {
    this.yes = yes;
    this.abstain = abstain;
    this.no = no;
    this.noWithVeto = noWithVeto;
  }
}

export function encodeTallyResult(message: TallyResult): Uint8Array {
  return Protobuf.encode(message, TallyResult.encode);
}

export function decodeTallyResult(buffer: Uint8Array): TallyResult {
  return Protobuf.decode<TallyResult>(buffer, TallyResult.decode);
}

export class Vote {
  static encode(message: Vote, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.proposalId);

    writer.uint32(18);
    writer.string(message.voter);

    writer.uint32(24);
    writer.int32(message.option);

    const options = message.options;
    for (let i = 0; i < options.length; ++i) {
      writer.uint32(34);
      writer.fork();
      WeightedVoteOption.encode(options[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Vote {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Vote();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.proposalId = reader.uint64();
          break;

        case 2:
          message.voter = reader.string();
          break;

        case 3:
          message.option = reader.int32();
          break;

        case 4:
          message.options.push(
            WeightedVoteOption.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  proposalId: u64;
  voter: string;
  option: VoteOption;
  options: Array<WeightedVoteOption>;

  constructor(
    proposalId: u64 = 0,
    voter: string = "",
    option: VoteOption = 0,
    options: Array<WeightedVoteOption> = []
  ) {
    this.proposalId = proposalId;
    this.voter = voter;
    this.option = option;
    this.options = options;
  }
}

export function encodeVote(message: Vote): Uint8Array {
  return Protobuf.encode(message, Vote.encode);
}

export function decodeVote(buffer: Uint8Array): Vote {
  return Protobuf.decode<Vote>(buffer, Vote.decode);
}

export class DepositParams {
  static encode(message: DepositParams, writer: Writer): void {
    const minDeposit = message.minDeposit;
    for (let i = 0; i < minDeposit.length; ++i) {
      writer.uint32(10);
      writer.fork();
      base.v1beta1.Coin.encode(minDeposit[i], writer);
      writer.ldelim();
    }

    const maxDepositPeriod = message.maxDepositPeriod;
    if (maxDepositPeriod !== null) {
      writer.uint32(18);
      writer.fork();
      google.protobuf.Duration.encode(maxDepositPeriod, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): DepositParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new DepositParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.minDeposit.push(
            base.v1beta1.Coin.decode(reader, reader.uint32())
          );
          break;

        case 2:
          message.maxDepositPeriod = google.protobuf.Duration.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  minDeposit: Array<base.v1beta1.Coin>;
  maxDepositPeriod: google.protobuf.Duration | null;

  constructor(
    minDeposit: Array<base.v1beta1.Coin> = [],
    maxDepositPeriod: google.protobuf.Duration | null = null
  ) {
    this.minDeposit = minDeposit;
    this.maxDepositPeriod = maxDepositPeriod;
  }
}

export function encodeDepositParams(message: DepositParams): Uint8Array {
  return Protobuf.encode(message, DepositParams.encode);
}

export function decodeDepositParams(buffer: Uint8Array): DepositParams {
  return Protobuf.decode<DepositParams>(buffer, DepositParams.decode);
}

@unmanaged
export class VotingParams {
  static encode(message: VotingParams, writer: Writer): void {
    const votingPeriod = message.votingPeriod;
    if (votingPeriod !== null) {
      writer.uint32(10);
      writer.fork();
      google.protobuf.Duration.encode(votingPeriod, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): VotingParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new VotingParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.votingPeriod = google.protobuf.Duration.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  votingPeriod: google.protobuf.Duration | null;

  constructor(votingPeriod: google.protobuf.Duration | null = null) {
    this.votingPeriod = votingPeriod;
  }
}

export function encodeVotingParams(message: VotingParams): Uint8Array {
  return Protobuf.encode(message, VotingParams.encode);
}

export function decodeVotingParams(buffer: Uint8Array): VotingParams {
  return Protobuf.decode<VotingParams>(buffer, VotingParams.decode);
}

export class TallyParams {
  static encode(message: TallyParams, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.quorum);

    writer.uint32(18);
    writer.bytes(message.threshold);

    writer.uint32(26);
    writer.bytes(message.vetoThreshold);
  }

  static decode(reader: Reader, length: i32): TallyParams {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new TallyParams();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.quorum = reader.bytes();
          break;

        case 2:
          message.threshold = reader.bytes();
          break;

        case 3:
          message.vetoThreshold = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  quorum: Uint8Array;
  threshold: Uint8Array;
  vetoThreshold: Uint8Array;

  constructor(
    quorum: Uint8Array = new Uint8Array(0),
    threshold: Uint8Array = new Uint8Array(0),
    vetoThreshold: Uint8Array = new Uint8Array(0)
  ) {
    this.quorum = quorum;
    this.threshold = threshold;
    this.vetoThreshold = vetoThreshold;
  }
}

export function encodeTallyParams(message: TallyParams): Uint8Array {
  return Protobuf.encode(message, TallyParams.encode);
}

export function decodeTallyParams(buffer: Uint8Array): TallyParams {
  return Protobuf.decode<TallyParams>(buffer, TallyParams.decode);
}

export enum VoteOption {
  VOTE_OPTION_UNSPECIFIED = 0,
  VOTE_OPTION_YES = 1,
  VOTE_OPTION_ABSTAIN = 2,
  VOTE_OPTION_NO = 3,
  VOTE_OPTION_NO_WITH_VETO = 4,
}

export enum ProposalStatus {
  PROPOSAL_STATUS_UNSPECIFIED = 0,
  PROPOSAL_STATUS_DEPOSIT_PERIOD = 1,
  PROPOSAL_STATUS_VOTING_PERIOD = 2,
  PROPOSAL_STATUS_PASSED = 3,
  PROPOSAL_STATUS_REJECTED = 4,
  PROPOSAL_STATUS_FAILED = 5,
}
