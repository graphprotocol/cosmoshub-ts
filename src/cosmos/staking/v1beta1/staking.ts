// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.4.0
//   protoc        v3.21.7

import { Writer, Reader, Protobuf } from "as-proto";
import { tendermint } from "../../../tendermint";
import { google } from "../../../google";
import { base } from "../../base";

export class HistoricalInfo {
  static encode(message: HistoricalInfo, writer: Writer): void {
    const header = message.header;
    if (header !== null) {
      writer.uint32(10);
      writer.fork();
      tendermint.types.Header.encode(header, writer);
      writer.ldelim();
    }

    const valset = message.valset;
    for (let i = 0; i < valset.length; ++i) {
      writer.uint32(18);
      writer.fork();
      Validator.encode(valset[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): HistoricalInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new HistoricalInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.header = tendermint.types.Header.decode(
            reader,
            reader.uint32()
          );
          break;

        case 2:
          message.valset.push(Validator.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  header: tendermint.types.Header | null;
  valset: Array<Validator>;

  constructor(
    header: tendermint.types.Header | null = null,
    valset: Array<Validator> = []
  ) {
    this.header = header;
    this.valset = valset;
  }
}

export function encodeHistoricalInfo(message: HistoricalInfo): Uint8Array {
  return Protobuf.encode(message, HistoricalInfo.encode);
}

export function decodeHistoricalInfo(buffer: Uint8Array): HistoricalInfo {
  return Protobuf.decode<HistoricalInfo>(buffer, HistoricalInfo.decode);
}

export class CommissionRates {
  static encode(message: CommissionRates, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.rate);

    writer.uint32(18);
    writer.string(message.maxRate);

    writer.uint32(26);
    writer.string(message.maxChangeRate);
  }

  static decode(reader: Reader, length: i32): CommissionRates {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CommissionRates();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.rate = reader.string();
          break;

        case 2:
          message.maxRate = reader.string();
          break;

        case 3:
          message.maxChangeRate = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  rate: string;
  maxRate: string;
  maxChangeRate: string;

  constructor(
    rate: string = "",
    maxRate: string = "",
    maxChangeRate: string = ""
  ) {
    this.rate = rate;
    this.maxRate = maxRate;
    this.maxChangeRate = maxChangeRate;
  }
}

export function encodeCommissionRates(message: CommissionRates): Uint8Array {
  return Protobuf.encode(message, CommissionRates.encode);
}

export function decodeCommissionRates(buffer: Uint8Array): CommissionRates {
  return Protobuf.decode<CommissionRates>(buffer, CommissionRates.decode);
}

export class Commission {
  static encode(message: Commission, writer: Writer): void {
    const commissionRates = message.commissionRates;
    if (commissionRates !== null) {
      writer.uint32(10);
      writer.fork();
      CommissionRates.encode(commissionRates, writer);
      writer.ldelim();
    }

    const updateTime = message.updateTime;
    if (updateTime !== null) {
      writer.uint32(18);
      writer.fork();
      google.protobuf.Timestamp.encode(updateTime, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Commission {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Commission();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.commissionRates = CommissionRates.decode(
            reader,
            reader.uint32()
          );
          break;

        case 2:
          message.updateTime = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  commissionRates: CommissionRates | null;
  updateTime: google.protobuf.Timestamp | null;

  constructor(
    commissionRates: CommissionRates | null = null,
    updateTime: google.protobuf.Timestamp | null = null
  ) {
    this.commissionRates = commissionRates;
    this.updateTime = updateTime;
  }
}

export function encodeCommission(message: Commission): Uint8Array {
  return Protobuf.encode(message, Commission.encode);
}

export function decodeCommission(buffer: Uint8Array): Commission {
  return Protobuf.decode<Commission>(buffer, Commission.decode);
}

export class Description {
  static encode(message: Description, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.moniker);

    writer.uint32(18);
    writer.string(message.identity);

    writer.uint32(26);
    writer.string(message.website);

    writer.uint32(34);
    writer.string(message.securityContact);

    writer.uint32(42);
    writer.string(message.details);
  }

  static decode(reader: Reader, length: i32): Description {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Description();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.moniker = reader.string();
          break;

        case 2:
          message.identity = reader.string();
          break;

        case 3:
          message.website = reader.string();
          break;

        case 4:
          message.securityContact = reader.string();
          break;

        case 5:
          message.details = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  moniker: string;
  identity: string;
  website: string;
  securityContact: string;
  details: string;

  constructor(
    moniker: string = "",
    identity: string = "",
    website: string = "",
    securityContact: string = "",
    details: string = ""
  ) {
    this.moniker = moniker;
    this.identity = identity;
    this.website = website;
    this.securityContact = securityContact;
    this.details = details;
  }
}

export function encodeDescription(message: Description): Uint8Array {
  return Protobuf.encode(message, Description.encode);
}

export function decodeDescription(buffer: Uint8Array): Description {
  return Protobuf.decode<Description>(buffer, Description.decode);
}

export class Validator {
  static encode(message: Validator, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.operatorAddress);

    const consensusPubkey = message.consensusPubkey;
    if (consensusPubkey !== null) {
      writer.uint32(18);
      writer.fork();
      google.protobuf.Any.encode(consensusPubkey, writer);
      writer.ldelim();
    }

    writer.uint32(24);
    writer.bool(message.jailed);

    writer.uint32(32);
    writer.int32(message.status);

    writer.uint32(42);
    writer.string(message.tokens);

    writer.uint32(50);
    writer.string(message.delegatorShares);

    const description = message.description;
    if (description !== null) {
      writer.uint32(58);
      writer.fork();
      Description.encode(description, writer);
      writer.ldelim();
    }

    writer.uint32(64);
    writer.int64(message.unbondingHeight);

    const unbondingTime = message.unbondingTime;
    if (unbondingTime !== null) {
      writer.uint32(74);
      writer.fork();
      google.protobuf.Timestamp.encode(unbondingTime, writer);
      writer.ldelim();
    }

    const commission = message.commission;
    if (commission !== null) {
      writer.uint32(82);
      writer.fork();
      Commission.encode(commission, writer);
      writer.ldelim();
    }

    writer.uint32(90);
    writer.string(message.minSelfDelegation);
  }

  static decode(reader: Reader, length: i32): Validator {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Validator();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.operatorAddress = reader.string();
          break;

        case 2:
          message.consensusPubkey = google.protobuf.Any.decode(
            reader,
            reader.uint32()
          );
          break;

        case 3:
          message.jailed = reader.bool();
          break;

        case 4:
          message.status = reader.int32();
          break;

        case 5:
          message.tokens = reader.string();
          break;

        case 6:
          message.delegatorShares = reader.string();
          break;

        case 7:
          message.description = Description.decode(reader, reader.uint32());
          break;

        case 8:
          message.unbondingHeight = reader.int64();
          break;

        case 9:
          message.unbondingTime = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 10:
          message.commission = Commission.decode(reader, reader.uint32());
          break;

        case 11:
          message.minSelfDelegation = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  operatorAddress: string;
  consensusPubkey: google.protobuf.Any | null;
  jailed: bool;
  status: BondStatus;
  tokens: string;
  delegatorShares: string;
  description: Description | null;
  unbondingHeight: i64;
  unbondingTime: google.protobuf.Timestamp | null;
  commission: Commission | null;
  minSelfDelegation: string;

  constructor(
    operatorAddress: string = "",
    consensusPubkey: google.protobuf.Any | null = null,
    jailed: bool = false,
    status: BondStatus = 0,
    tokens: string = "",
    delegatorShares: string = "",
    description: Description | null = null,
    unbondingHeight: i64 = 0,
    unbondingTime: google.protobuf.Timestamp | null = null,
    commission: Commission | null = null,
    minSelfDelegation: string = ""
  ) {
    this.operatorAddress = operatorAddress;
    this.consensusPubkey = consensusPubkey;
    this.jailed = jailed;
    this.status = status;
    this.tokens = tokens;
    this.delegatorShares = delegatorShares;
    this.description = description;
    this.unbondingHeight = unbondingHeight;
    this.unbondingTime = unbondingTime;
    this.commission = commission;
    this.minSelfDelegation = minSelfDelegation;
  }
}

export function encodeValidator(message: Validator): Uint8Array {
  return Protobuf.encode(message, Validator.encode);
}

export function decodeValidator(buffer: Uint8Array): Validator {
  return Protobuf.decode<Validator>(buffer, Validator.decode);
}

export class ValAddresses {
  static encode(message: ValAddresses, writer: Writer): void {
    const addresses = message.addresses;
    if (addresses.length !== 0) {
      for (let i = 0; i < addresses.length; ++i) {
        writer.uint32(10);
        writer.string(addresses[i]);
      }
    }
  }

  static decode(reader: Reader, length: i32): ValAddresses {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ValAddresses();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.addresses.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  addresses: Array<string>;

  constructor(addresses: Array<string> = []) {
    this.addresses = addresses;
  }
}

export function encodeValAddresses(message: ValAddresses): Uint8Array {
  return Protobuf.encode(message, ValAddresses.encode);
}

export function decodeValAddresses(buffer: Uint8Array): ValAddresses {
  return Protobuf.decode<ValAddresses>(buffer, ValAddresses.decode);
}

export class DVPair {
  static encode(message: DVPair, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.delegatorAddress);

    writer.uint32(18);
    writer.string(message.validatorAddress);
  }

  static decode(reader: Reader, length: i32): DVPair {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new DVPair();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegatorAddress = reader.string();
          break;

        case 2:
          message.validatorAddress = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  delegatorAddress: string;
  validatorAddress: string;

  constructor(delegatorAddress: string = "", validatorAddress: string = "") {
    this.delegatorAddress = delegatorAddress;
    this.validatorAddress = validatorAddress;
  }
}

export function encodeDVPair(message: DVPair): Uint8Array {
  return Protobuf.encode(message, DVPair.encode);
}

export function decodeDVPair(buffer: Uint8Array): DVPair {
  return Protobuf.decode<DVPair>(buffer, DVPair.decode);
}

export class DVPairs {
  static encode(message: DVPairs, writer: Writer): void {
    const pairs = message.pairs;
    for (let i = 0; i < pairs.length; ++i) {
      writer.uint32(10);
      writer.fork();
      DVPair.encode(pairs[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): DVPairs {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new DVPairs();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.pairs.push(DVPair.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  pairs: Array<DVPair>;

  constructor(pairs: Array<DVPair> = []) {
    this.pairs = pairs;
  }
}

export function encodeDVPairs(message: DVPairs): Uint8Array {
  return Protobuf.encode(message, DVPairs.encode);
}

export function decodeDVPairs(buffer: Uint8Array): DVPairs {
  return Protobuf.decode<DVPairs>(buffer, DVPairs.decode);
}

export class DVVTriplet {
  static encode(message: DVVTriplet, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.delegatorAddress);

    writer.uint32(18);
    writer.string(message.validatorSrcAddress);

    writer.uint32(26);
    writer.string(message.validatorDstAddress);
  }

  static decode(reader: Reader, length: i32): DVVTriplet {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new DVVTriplet();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegatorAddress = reader.string();
          break;

        case 2:
          message.validatorSrcAddress = reader.string();
          break;

        case 3:
          message.validatorDstAddress = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  delegatorAddress: string;
  validatorSrcAddress: string;
  validatorDstAddress: string;

  constructor(
    delegatorAddress: string = "",
    validatorSrcAddress: string = "",
    validatorDstAddress: string = ""
  ) {
    this.delegatorAddress = delegatorAddress;
    this.validatorSrcAddress = validatorSrcAddress;
    this.validatorDstAddress = validatorDstAddress;
  }
}

export function encodeDVVTriplet(message: DVVTriplet): Uint8Array {
  return Protobuf.encode(message, DVVTriplet.encode);
}

export function decodeDVVTriplet(buffer: Uint8Array): DVVTriplet {
  return Protobuf.decode<DVVTriplet>(buffer, DVVTriplet.decode);
}

export class DVVTriplets {
  static encode(message: DVVTriplets, writer: Writer): void {
    const triplets = message.triplets;
    for (let i = 0; i < triplets.length; ++i) {
      writer.uint32(10);
      writer.fork();
      DVVTriplet.encode(triplets[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): DVVTriplets {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new DVVTriplets();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.triplets.push(DVVTriplet.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  triplets: Array<DVVTriplet>;

  constructor(triplets: Array<DVVTriplet> = []) {
    this.triplets = triplets;
  }
}

export function encodeDVVTriplets(message: DVVTriplets): Uint8Array {
  return Protobuf.encode(message, DVVTriplets.encode);
}

export function decodeDVVTriplets(buffer: Uint8Array): DVVTriplets {
  return Protobuf.decode<DVVTriplets>(buffer, DVVTriplets.decode);
}

export class Delegation {
  static encode(message: Delegation, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.delegatorAddress);

    writer.uint32(18);
    writer.string(message.validatorAddress);

    writer.uint32(26);
    writer.string(message.shares);
  }

  static decode(reader: Reader, length: i32): Delegation {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Delegation();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegatorAddress = reader.string();
          break;

        case 2:
          message.validatorAddress = reader.string();
          break;

        case 3:
          message.shares = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  delegatorAddress: string;
  validatorAddress: string;
  shares: string;

  constructor(
    delegatorAddress: string = "",
    validatorAddress: string = "",
    shares: string = ""
  ) {
    this.delegatorAddress = delegatorAddress;
    this.validatorAddress = validatorAddress;
    this.shares = shares;
  }
}

export function encodeDelegation(message: Delegation): Uint8Array {
  return Protobuf.encode(message, Delegation.encode);
}

export function decodeDelegation(buffer: Uint8Array): Delegation {
  return Protobuf.decode<Delegation>(buffer, Delegation.decode);
}

export class UnbondingDelegation {
  static encode(message: UnbondingDelegation, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.delegatorAddress);

    writer.uint32(18);
    writer.string(message.validatorAddress);

    const entries = message.entries;
    for (let i = 0; i < entries.length; ++i) {
      writer.uint32(26);
      writer.fork();
      UnbondingDelegationEntry.encode(entries[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): UnbondingDelegation {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new UnbondingDelegation();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegatorAddress = reader.string();
          break;

        case 2:
          message.validatorAddress = reader.string();
          break;

        case 3:
          message.entries.push(
            UnbondingDelegationEntry.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  delegatorAddress: string;
  validatorAddress: string;
  entries: Array<UnbondingDelegationEntry>;

  constructor(
    delegatorAddress: string = "",
    validatorAddress: string = "",
    entries: Array<UnbondingDelegationEntry> = []
  ) {
    this.delegatorAddress = delegatorAddress;
    this.validatorAddress = validatorAddress;
    this.entries = entries;
  }
}

export function encodeUnbondingDelegation(
  message: UnbondingDelegation
): Uint8Array {
  return Protobuf.encode(message, UnbondingDelegation.encode);
}

export function decodeUnbondingDelegation(
  buffer: Uint8Array
): UnbondingDelegation {
  return Protobuf.decode<UnbondingDelegation>(
    buffer,
    UnbondingDelegation.decode
  );
}

export class UnbondingDelegationEntry {
  static encode(message: UnbondingDelegationEntry, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.creationHeight);

    const completionTime = message.completionTime;
    if (completionTime !== null) {
      writer.uint32(18);
      writer.fork();
      google.protobuf.Timestamp.encode(completionTime, writer);
      writer.ldelim();
    }

    writer.uint32(26);
    writer.string(message.initialBalance);

    writer.uint32(34);
    writer.string(message.balance);
  }

  static decode(reader: Reader, length: i32): UnbondingDelegationEntry {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new UnbondingDelegationEntry();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.creationHeight = reader.int64();
          break;

        case 2:
          message.completionTime = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 3:
          message.initialBalance = reader.string();
          break;

        case 4:
          message.balance = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  creationHeight: i64;
  completionTime: google.protobuf.Timestamp | null;
  initialBalance: string;
  balance: string;

  constructor(
    creationHeight: i64 = 0,
    completionTime: google.protobuf.Timestamp | null = null,
    initialBalance: string = "",
    balance: string = ""
  ) {
    this.creationHeight = creationHeight;
    this.completionTime = completionTime;
    this.initialBalance = initialBalance;
    this.balance = balance;
  }
}

export function encodeUnbondingDelegationEntry(
  message: UnbondingDelegationEntry
): Uint8Array {
  return Protobuf.encode(message, UnbondingDelegationEntry.encode);
}

export function decodeUnbondingDelegationEntry(
  buffer: Uint8Array
): UnbondingDelegationEntry {
  return Protobuf.decode<UnbondingDelegationEntry>(
    buffer,
    UnbondingDelegationEntry.decode
  );
}

export class RedelegationEntry {
  static encode(message: RedelegationEntry, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.creationHeight);

    const completionTime = message.completionTime;
    if (completionTime !== null) {
      writer.uint32(18);
      writer.fork();
      google.protobuf.Timestamp.encode(completionTime, writer);
      writer.ldelim();
    }

    writer.uint32(26);
    writer.string(message.initialBalance);

    writer.uint32(34);
    writer.string(message.sharesDst);
  }

  static decode(reader: Reader, length: i32): RedelegationEntry {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RedelegationEntry();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.creationHeight = reader.int64();
          break;

        case 2:
          message.completionTime = google.protobuf.Timestamp.decode(
            reader,
            reader.uint32()
          );
          break;

        case 3:
          message.initialBalance = reader.string();
          break;

        case 4:
          message.sharesDst = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  creationHeight: i64;
  completionTime: google.protobuf.Timestamp | null;
  initialBalance: string;
  sharesDst: string;

  constructor(
    creationHeight: i64 = 0,
    completionTime: google.protobuf.Timestamp | null = null,
    initialBalance: string = "",
    sharesDst: string = ""
  ) {
    this.creationHeight = creationHeight;
    this.completionTime = completionTime;
    this.initialBalance = initialBalance;
    this.sharesDst = sharesDst;
  }
}

export function encodeRedelegationEntry(
  message: RedelegationEntry
): Uint8Array {
  return Protobuf.encode(message, RedelegationEntry.encode);
}

export function decodeRedelegationEntry(buffer: Uint8Array): RedelegationEntry {
  return Protobuf.decode<RedelegationEntry>(buffer, RedelegationEntry.decode);
}

export class Redelegation {
  static encode(message: Redelegation, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.delegatorAddress);

    writer.uint32(18);
    writer.string(message.validatorSrcAddress);

    writer.uint32(26);
    writer.string(message.validatorDstAddress);

    const entries = message.entries;
    for (let i = 0; i < entries.length; ++i) {
      writer.uint32(34);
      writer.fork();
      RedelegationEntry.encode(entries[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Redelegation {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Redelegation();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegatorAddress = reader.string();
          break;

        case 2:
          message.validatorSrcAddress = reader.string();
          break;

        case 3:
          message.validatorDstAddress = reader.string();
          break;

        case 4:
          message.entries.push(
            RedelegationEntry.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  delegatorAddress: string;
  validatorSrcAddress: string;
  validatorDstAddress: string;
  entries: Array<RedelegationEntry>;

  constructor(
    delegatorAddress: string = "",
    validatorSrcAddress: string = "",
    validatorDstAddress: string = "",
    entries: Array<RedelegationEntry> = []
  ) {
    this.delegatorAddress = delegatorAddress;
    this.validatorSrcAddress = validatorSrcAddress;
    this.validatorDstAddress = validatorDstAddress;
    this.entries = entries;
  }
}

export function encodeRedelegation(message: Redelegation): Uint8Array {
  return Protobuf.encode(message, Redelegation.encode);
}

export function decodeRedelegation(buffer: Uint8Array): Redelegation {
  return Protobuf.decode<Redelegation>(buffer, Redelegation.decode);
}

export class Params {
  static encode(message: Params, writer: Writer): void {
    const unbondingTime = message.unbondingTime;
    if (unbondingTime !== null) {
      writer.uint32(10);
      writer.fork();
      google.protobuf.Duration.encode(unbondingTime, writer);
      writer.ldelim();
    }

    writer.uint32(16);
    writer.uint32(message.maxValidators);

    writer.uint32(24);
    writer.uint32(message.maxEntries);

    writer.uint32(32);
    writer.uint32(message.historicalEntries);

    writer.uint32(42);
    writer.string(message.bondDenom);
  }

  static decode(reader: Reader, length: i32): Params {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Params();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.unbondingTime = google.protobuf.Duration.decode(
            reader,
            reader.uint32()
          );
          break;

        case 2:
          message.maxValidators = reader.uint32();
          break;

        case 3:
          message.maxEntries = reader.uint32();
          break;

        case 4:
          message.historicalEntries = reader.uint32();
          break;

        case 5:
          message.bondDenom = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  unbondingTime: google.protobuf.Duration | null;
  maxValidators: u32;
  maxEntries: u32;
  historicalEntries: u32;
  bondDenom: string;

  constructor(
    unbondingTime: google.protobuf.Duration | null = null,
    maxValidators: u32 = 0,
    maxEntries: u32 = 0,
    historicalEntries: u32 = 0,
    bondDenom: string = ""
  ) {
    this.unbondingTime = unbondingTime;
    this.maxValidators = maxValidators;
    this.maxEntries = maxEntries;
    this.historicalEntries = historicalEntries;
    this.bondDenom = bondDenom;
  }
}

export function encodeParams(message: Params): Uint8Array {
  return Protobuf.encode(message, Params.encode);
}

export function decodeParams(buffer: Uint8Array): Params {
  return Protobuf.decode<Params>(buffer, Params.decode);
}

export class DelegationResponse {
  static encode(message: DelegationResponse, writer: Writer): void {
    const delegation = message.delegation;
    if (delegation !== null) {
      writer.uint32(10);
      writer.fork();
      Delegation.encode(delegation, writer);
      writer.ldelim();
    }

    const balance = message.balance;
    if (balance !== null) {
      writer.uint32(18);
      writer.fork();
      base.v1beta1.Coin.encode(balance, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): DelegationResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new DelegationResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegation = Delegation.decode(reader, reader.uint32());
          break;

        case 2:
          message.balance = base.v1beta1.Coin.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  delegation: Delegation | null;
  balance: base.v1beta1.Coin | null;

  constructor(
    delegation: Delegation | null = null,
    balance: base.v1beta1.Coin | null = null
  ) {
    this.delegation = delegation;
    this.balance = balance;
  }
}

export function encodeDelegationResponse(
  message: DelegationResponse
): Uint8Array {
  return Protobuf.encode(message, DelegationResponse.encode);
}

export function decodeDelegationResponse(
  buffer: Uint8Array
): DelegationResponse {
  return Protobuf.decode<DelegationResponse>(buffer, DelegationResponse.decode);
}

export class RedelegationEntryResponse {
  static encode(message: RedelegationEntryResponse, writer: Writer): void {
    const redelegationEntry = message.redelegationEntry;
    if (redelegationEntry !== null) {
      writer.uint32(10);
      writer.fork();
      RedelegationEntry.encode(redelegationEntry, writer);
      writer.ldelim();
    }

    writer.uint32(34);
    writer.string(message.balance);
  }

  static decode(reader: Reader, length: i32): RedelegationEntryResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RedelegationEntryResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.redelegationEntry = RedelegationEntry.decode(
            reader,
            reader.uint32()
          );
          break;

        case 4:
          message.balance = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  redelegationEntry: RedelegationEntry | null;
  balance: string;

  constructor(
    redelegationEntry: RedelegationEntry | null = null,
    balance: string = ""
  ) {
    this.redelegationEntry = redelegationEntry;
    this.balance = balance;
  }
}

export function encodeRedelegationEntryResponse(
  message: RedelegationEntryResponse
): Uint8Array {
  return Protobuf.encode(message, RedelegationEntryResponse.encode);
}

export function decodeRedelegationEntryResponse(
  buffer: Uint8Array
): RedelegationEntryResponse {
  return Protobuf.decode<RedelegationEntryResponse>(
    buffer,
    RedelegationEntryResponse.decode
  );
}

export class RedelegationResponse {
  static encode(message: RedelegationResponse, writer: Writer): void {
    const redelegation = message.redelegation;
    if (redelegation !== null) {
      writer.uint32(10);
      writer.fork();
      Redelegation.encode(redelegation, writer);
      writer.ldelim();
    }

    const entries = message.entries;
    for (let i = 0; i < entries.length; ++i) {
      writer.uint32(18);
      writer.fork();
      RedelegationEntryResponse.encode(entries[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): RedelegationResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new RedelegationResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.redelegation = Redelegation.decode(reader, reader.uint32());
          break;

        case 2:
          message.entries.push(
            RedelegationEntryResponse.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  redelegation: Redelegation | null;
  entries: Array<RedelegationEntryResponse>;

  constructor(
    redelegation: Redelegation | null = null,
    entries: Array<RedelegationEntryResponse> = []
  ) {
    this.redelegation = redelegation;
    this.entries = entries;
  }
}

export function encodeRedelegationResponse(
  message: RedelegationResponse
): Uint8Array {
  return Protobuf.encode(message, RedelegationResponse.encode);
}

export function decodeRedelegationResponse(
  buffer: Uint8Array
): RedelegationResponse {
  return Protobuf.decode<RedelegationResponse>(
    buffer,
    RedelegationResponse.decode
  );
}

export class Pool {
  static encode(message: Pool, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.notBondedTokens);

    writer.uint32(18);
    writer.string(message.bondedTokens);
  }

  static decode(reader: Reader, length: i32): Pool {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Pool();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.notBondedTokens = reader.string();
          break;

        case 2:
          message.bondedTokens = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  notBondedTokens: string;
  bondedTokens: string;

  constructor(notBondedTokens: string = "", bondedTokens: string = "") {
    this.notBondedTokens = notBondedTokens;
    this.bondedTokens = bondedTokens;
  }
}

export function encodePool(message: Pool): Uint8Array {
  return Protobuf.encode(message, Pool.encode);
}

export function decodePool(buffer: Uint8Array): Pool {
  return Protobuf.decode<Pool>(buffer, Pool.decode);
}

export enum BondStatus {
  BOND_STATUS_UNSPECIFIED = 0,
  BOND_STATUS_UNBONDED = 1,
  BOND_STATUS_UNBONDING = 2,
  BOND_STATUS_BONDED = 3,
}
