// Code generated by protoc-gen-as. DO NOT EDIT.
// versions:
// 	 protoc-gen-as v0.3.0-alpha.3
// 	 protoc        v3.20.1
// source: cosmos/staking/v1beta1/tx.ts

import { Writer, Reader, Protobuf } from "as-proto";
import { Description, CommissionRates } from "./staking";
import { google } from "../../../google";
import { base } from "../../base";

export class MsgCreateValidator {
  static encode(message: MsgCreateValidator, writer: Writer): void {
    const description_ = message.description;
    if (description_ !== null) {
      writer.uint32(10);
      writer.fork();
      Description.encode(description_, writer);
      writer.ldelim();
    }

    const commission_ = message.commission;
    if (commission_ !== null) {
      writer.uint32(18);
      writer.fork();
      CommissionRates.encode(commission_, writer);
      writer.ldelim();
    }

    writer.uint32(26);
    writer.string(message.min_self_delegation);

    writer.uint32(34);
    writer.string(message.delegator_address);

    writer.uint32(42);
    writer.string(message.validator_address);

    const pubkey_ = message.pubkey;
    if (pubkey_ !== null) {
      writer.uint32(50);
      writer.fork();
      google.protobuf.Any.encode(pubkey_, writer);
      writer.ldelim();
    }

    const value_ = message.value;
    if (value_ !== null) {
      writer.uint32(58);
      writer.fork();
      base.v1beta1.Coin.encode(value_, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): MsgCreateValidator {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgCreateValidator();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.description = Description.decode(reader, reader.uint32());
          break;

        case 2:
          message.commission = CommissionRates.decode(reader, reader.uint32());
          break;

        case 3:
          message.min_self_delegation = reader.string();
          break;

        case 4:
          message.delegator_address = reader.string();
          break;

        case 5:
          message.validator_address = reader.string();
          break;

        case 6:
          message.pubkey = google.protobuf.Any.decode(reader, reader.uint32());
          break;

        case 7:
          message.value = base.v1beta1.Coin.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  description: Description | null;
  commission: CommissionRates | null;
  min_self_delegation: string;
  delegator_address: string;
  validator_address: string;
  pubkey: google.protobuf.Any | null;
  value: base.v1beta1.Coin | null;

  constructor(
    description: Description | null = null,
    commission: CommissionRates | null = null,
    min_self_delegation: string = "",
    delegator_address: string = "",
    validator_address: string = "",
    pubkey: google.protobuf.Any | null = null,
    value: base.v1beta1.Coin | null = null
  ) {
    this.description = description;
    this.commission = commission;
    this.min_self_delegation = min_self_delegation;
    this.delegator_address = delegator_address;
    this.validator_address = validator_address;
    this.pubkey = pubkey;
    this.value = value;
  }
}

export function decodeMsgCreateValidator(a: Uint8Array): MsgCreateValidator {
  return Protobuf.decode<MsgCreateValidator>(a, MsgCreateValidator.decode);
}

@unmanaged
export class MsgCreateValidatorResponse {
  static encode(message: MsgCreateValidatorResponse, writer: Writer): void {}

  static decode(reader: Reader, length: i32): MsgCreateValidatorResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgCreateValidatorResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function decodeMsgCreateValidatorResponse(a: Uint8Array): MsgCreateValidatorResponse {
  return Protobuf.decode<MsgCreateValidatorResponse>(a, MsgCreateValidatorResponse.decode);
}

export class MsgEditValidator {
  static encode(message: MsgEditValidator, writer: Writer): void {
    const description_ = message.description;
    if (description_ !== null) {
      writer.uint32(10);
      writer.fork();
      Description.encode(description_, writer);
      writer.ldelim();
    }

    writer.uint32(18);
    writer.string(message.validator_address);

    writer.uint32(26);
    writer.string(message.commission_rate);

    writer.uint32(34);
    writer.string(message.min_self_delegation);
  }

  static decode(reader: Reader, length: i32): MsgEditValidator {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgEditValidator();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.description = Description.decode(reader, reader.uint32());
          break;

        case 2:
          message.validator_address = reader.string();
          break;

        case 3:
          message.commission_rate = reader.string();
          break;

        case 4:
          message.min_self_delegation = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  description: Description | null;
  validator_address: string;
  commission_rate: string;
  min_self_delegation: string;

  constructor(
    description: Description | null = null,
    validator_address: string = "",
    commission_rate: string = "",
    min_self_delegation: string = ""
  ) {
    this.description = description;
    this.validator_address = validator_address;
    this.commission_rate = commission_rate;
    this.min_self_delegation = min_self_delegation;
  }
}

export function decodeMsgEditValidator(a: Uint8Array): MsgEditValidator {
  return Protobuf.decode<MsgEditValidator>(a, MsgEditValidator.decode);
}

@unmanaged
export class MsgEditValidatorResponse {
  static encode(message: MsgEditValidatorResponse, writer: Writer): void {}

  static decode(reader: Reader, length: i32): MsgEditValidatorResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgEditValidatorResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function decodeMsgEditValidatorResponse(a: Uint8Array): MsgEditValidatorResponse {
  return Protobuf.decode<MsgEditValidatorResponse>(a, MsgEditValidatorResponse.decode);
}

export class MsgDelegate {
  static encode(message: MsgDelegate, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.delegator_address);

    writer.uint32(18);
    writer.string(message.validator_address);

    const amount_ = message.amount;
    if (amount_ !== null) {
      writer.uint32(26);
      writer.fork();
      base.v1beta1.Coin.encode(amount_, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): MsgDelegate {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgDelegate();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegator_address = reader.string();
          break;

        case 2:
          message.validator_address = reader.string();
          break;

        case 3:
          message.amount = base.v1beta1.Coin.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  delegator_address: string;
  validator_address: string;
  amount: base.v1beta1.Coin | null;

  constructor(delegator_address: string = "", validator_address: string = "", amount: base.v1beta1.Coin | null = null) {
    this.delegator_address = delegator_address;
    this.validator_address = validator_address;
    this.amount = amount;
  }
}

export function decodeMsgDelegate(a: Uint8Array): MsgDelegate {
  return Protobuf.decode<MsgDelegate>(a, MsgDelegate.decode);
}

@unmanaged
export class MsgDelegateResponse {
  static encode(message: MsgDelegateResponse, writer: Writer): void {}

  static decode(reader: Reader, length: i32): MsgDelegateResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgDelegateResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function decodeMsgDelegateResponse(a: Uint8Array): MsgDelegateResponse {
  return Protobuf.decode<MsgDelegateResponse>(a, MsgDelegateResponse.decode);
}

export class MsgBeginRedelegate {
  static encode(message: MsgBeginRedelegate, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.delegator_address);

    writer.uint32(18);
    writer.string(message.validator_src_address);

    writer.uint32(26);
    writer.string(message.validator_dst_address);

    const amount_ = message.amount;
    if (amount_ !== null) {
      writer.uint32(34);
      writer.fork();
      base.v1beta1.Coin.encode(amount_, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): MsgBeginRedelegate {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgBeginRedelegate();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegator_address = reader.string();
          break;

        case 2:
          message.validator_src_address = reader.string();
          break;

        case 3:
          message.validator_dst_address = reader.string();
          break;

        case 4:
          message.amount = base.v1beta1.Coin.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  delegator_address: string;
  validator_src_address: string;
  validator_dst_address: string;
  amount: base.v1beta1.Coin | null;

  constructor(
    delegator_address: string = "",
    validator_src_address: string = "",
    validator_dst_address: string = "",
    amount: base.v1beta1.Coin | null = null
  ) {
    this.delegator_address = delegator_address;
    this.validator_src_address = validator_src_address;
    this.validator_dst_address = validator_dst_address;
    this.amount = amount;
  }
}

export function decodeMsgBeginRedelegate(a: Uint8Array): MsgBeginRedelegate {
  return Protobuf.decode<MsgBeginRedelegate>(a, MsgBeginRedelegate.decode);
}

@unmanaged
export class MsgBeginRedelegateResponse {
  static encode(message: MsgBeginRedelegateResponse, writer: Writer): void {
    const completion_time_ = message.completion_time;
    if (completion_time_ !== null) {
      writer.uint32(10);
      writer.fork();
      google.protobuf.Timestamp.encode(completion_time_, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): MsgBeginRedelegateResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgBeginRedelegateResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.completion_time = google.protobuf.Timestamp.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  completion_time: google.protobuf.Timestamp | null;

  constructor(completion_time: google.protobuf.Timestamp | null = null) {
    this.completion_time = completion_time;
  }
}

export function decodeMsgBeginRedelegateResponse(a: Uint8Array): MsgBeginRedelegateResponse {
  return Protobuf.decode<MsgBeginRedelegateResponse>(a, MsgBeginRedelegateResponse.decode);
}

export class MsgUndelegate {
  static encode(message: MsgUndelegate, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.delegator_address);

    writer.uint32(18);
    writer.string(message.validator_address);

    const amount_ = message.amount;
    if (amount_ !== null) {
      writer.uint32(26);
      writer.fork();
      base.v1beta1.Coin.encode(amount_, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): MsgUndelegate {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgUndelegate();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.delegator_address = reader.string();
          break;

        case 2:
          message.validator_address = reader.string();
          break;

        case 3:
          message.amount = base.v1beta1.Coin.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  delegator_address: string;
  validator_address: string;
  amount: base.v1beta1.Coin | null;

  constructor(delegator_address: string = "", validator_address: string = "", amount: base.v1beta1.Coin | null = null) {
    this.delegator_address = delegator_address;
    this.validator_address = validator_address;
    this.amount = amount;
  }
}

export function decodeMsgUndelegate(a: Uint8Array): MsgUndelegate {
  return Protobuf.decode<MsgUndelegate>(a, MsgUndelegate.decode);
}

@unmanaged
export class MsgUndelegateResponse {
  static encode(message: MsgUndelegateResponse, writer: Writer): void {
    const completion_time_ = message.completion_time;
    if (completion_time_ !== null) {
      writer.uint32(10);
      writer.fork();
      google.protobuf.Timestamp.encode(completion_time_, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): MsgUndelegateResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgUndelegateResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.completion_time = google.protobuf.Timestamp.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  completion_time: google.protobuf.Timestamp | null;

  constructor(completion_time: google.protobuf.Timestamp | null = null) {
    this.completion_time = completion_time;
  }
}

export function decodeMsgUndelegateResponse(a: Uint8Array): MsgUndelegateResponse {
  return Protobuf.decode<MsgUndelegateResponse>(a, MsgUndelegateResponse.decode);
}
