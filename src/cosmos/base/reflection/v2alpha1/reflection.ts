// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.4.0
//   protoc        v3.21.7

import { Writer, Reader, Protobuf } from "as-proto";

export class AppDescriptor {
  static encode(message: AppDescriptor, writer: Writer): void {
    const authn = message.authn;
    if (authn !== null) {
      writer.uint32(10);
      writer.fork();
      AuthnDescriptor.encode(authn, writer);
      writer.ldelim();
    }

    const chain = message.chain;
    if (chain !== null) {
      writer.uint32(18);
      writer.fork();
      ChainDescriptor.encode(chain, writer);
      writer.ldelim();
    }

    const codec = message.codec;
    if (codec !== null) {
      writer.uint32(26);
      writer.fork();
      CodecDescriptor.encode(codec, writer);
      writer.ldelim();
    }

    const configuration = message.configuration;
    if (configuration !== null) {
      writer.uint32(34);
      writer.fork();
      ConfigurationDescriptor.encode(configuration, writer);
      writer.ldelim();
    }

    const queryServices = message.queryServices;
    if (queryServices !== null) {
      writer.uint32(42);
      writer.fork();
      QueryServicesDescriptor.encode(queryServices, writer);
      writer.ldelim();
    }

    const tx = message.tx;
    if (tx !== null) {
      writer.uint32(50);
      writer.fork();
      TxDescriptor.encode(tx, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): AppDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new AppDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authn = AuthnDescriptor.decode(reader, reader.uint32());
          break;

        case 2:
          message.chain = ChainDescriptor.decode(reader, reader.uint32());
          break;

        case 3:
          message.codec = CodecDescriptor.decode(reader, reader.uint32());
          break;

        case 4:
          message.configuration = ConfigurationDescriptor.decode(
            reader,
            reader.uint32()
          );
          break;

        case 5:
          message.queryServices = QueryServicesDescriptor.decode(
            reader,
            reader.uint32()
          );
          break;

        case 6:
          message.tx = TxDescriptor.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  authn: AuthnDescriptor | null;
  chain: ChainDescriptor | null;
  codec: CodecDescriptor | null;
  configuration: ConfigurationDescriptor | null;
  queryServices: QueryServicesDescriptor | null;
  tx: TxDescriptor | null;

  constructor(
    authn: AuthnDescriptor | null = null,
    chain: ChainDescriptor | null = null,
    codec: CodecDescriptor | null = null,
    configuration: ConfigurationDescriptor | null = null,
    queryServices: QueryServicesDescriptor | null = null,
    tx: TxDescriptor | null = null
  ) {
    this.authn = authn;
    this.chain = chain;
    this.codec = codec;
    this.configuration = configuration;
    this.queryServices = queryServices;
    this.tx = tx;
  }
}

export function encodeAppDescriptor(message: AppDescriptor): Uint8Array {
  return Protobuf.encode(message, AppDescriptor.encode);
}

export function decodeAppDescriptor(buffer: Uint8Array): AppDescriptor {
  return Protobuf.decode<AppDescriptor>(buffer, AppDescriptor.decode);
}

export class TxDescriptor {
  static encode(message: TxDescriptor, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.fullname);

    const msgs = message.msgs;
    for (let i = 0; i < msgs.length; ++i) {
      writer.uint32(18);
      writer.fork();
      MsgDescriptor.encode(msgs[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): TxDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new TxDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;

        case 2:
          message.msgs.push(MsgDescriptor.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  fullname: string;
  msgs: Array<MsgDescriptor>;

  constructor(fullname: string = "", msgs: Array<MsgDescriptor> = []) {
    this.fullname = fullname;
    this.msgs = msgs;
  }
}

export function encodeTxDescriptor(message: TxDescriptor): Uint8Array {
  return Protobuf.encode(message, TxDescriptor.encode);
}

export function decodeTxDescriptor(buffer: Uint8Array): TxDescriptor {
  return Protobuf.decode<TxDescriptor>(buffer, TxDescriptor.decode);
}

export class AuthnDescriptor {
  static encode(message: AuthnDescriptor, writer: Writer): void {
    const signModes = message.signModes;
    for (let i = 0; i < signModes.length; ++i) {
      writer.uint32(10);
      writer.fork();
      SigningModeDescriptor.encode(signModes[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): AuthnDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new AuthnDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signModes.push(
            SigningModeDescriptor.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  signModes: Array<SigningModeDescriptor>;

  constructor(signModes: Array<SigningModeDescriptor> = []) {
    this.signModes = signModes;
  }
}

export function encodeAuthnDescriptor(message: AuthnDescriptor): Uint8Array {
  return Protobuf.encode(message, AuthnDescriptor.encode);
}

export function decodeAuthnDescriptor(buffer: Uint8Array): AuthnDescriptor {
  return Protobuf.decode<AuthnDescriptor>(buffer, AuthnDescriptor.decode);
}

export class SigningModeDescriptor {
  static encode(message: SigningModeDescriptor, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.name);

    writer.uint32(16);
    writer.int32(message.number);

    writer.uint32(26);
    writer.string(message.authnInfoProviderMethodFullname);
  }

  static decode(reader: Reader, length: i32): SigningModeDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new SigningModeDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;

        case 2:
          message.number = reader.int32();
          break;

        case 3:
          message.authnInfoProviderMethodFullname = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  name: string;
  number: i32;
  authnInfoProviderMethodFullname: string;

  constructor(
    name: string = "",
    number: i32 = 0,
    authnInfoProviderMethodFullname: string = ""
  ) {
    this.name = name;
    this.number = number;
    this.authnInfoProviderMethodFullname = authnInfoProviderMethodFullname;
  }
}

export function encodeSigningModeDescriptor(
  message: SigningModeDescriptor
): Uint8Array {
  return Protobuf.encode(message, SigningModeDescriptor.encode);
}

export function decodeSigningModeDescriptor(
  buffer: Uint8Array
): SigningModeDescriptor {
  return Protobuf.decode<SigningModeDescriptor>(
    buffer,
    SigningModeDescriptor.decode
  );
}

export class ChainDescriptor {
  static encode(message: ChainDescriptor, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.id);
  }

  static decode(reader: Reader, length: i32): ChainDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ChainDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  id: string;

  constructor(id: string = "") {
    this.id = id;
  }
}

export function encodeChainDescriptor(message: ChainDescriptor): Uint8Array {
  return Protobuf.encode(message, ChainDescriptor.encode);
}

export function decodeChainDescriptor(buffer: Uint8Array): ChainDescriptor {
  return Protobuf.decode<ChainDescriptor>(buffer, ChainDescriptor.decode);
}

export class CodecDescriptor {
  static encode(message: CodecDescriptor, writer: Writer): void {
    const interfaces = message.interfaces;
    for (let i = 0; i < interfaces.length; ++i) {
      writer.uint32(10);
      writer.fork();
      InterfaceDescriptor.encode(interfaces[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): CodecDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new CodecDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.interfaces.push(
            InterfaceDescriptor.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  interfaces: Array<InterfaceDescriptor>;

  constructor(interfaces: Array<InterfaceDescriptor> = []) {
    this.interfaces = interfaces;
  }
}

export function encodeCodecDescriptor(message: CodecDescriptor): Uint8Array {
  return Protobuf.encode(message, CodecDescriptor.encode);
}

export function decodeCodecDescriptor(buffer: Uint8Array): CodecDescriptor {
  return Protobuf.decode<CodecDescriptor>(buffer, CodecDescriptor.decode);
}

export class InterfaceDescriptor {
  static encode(message: InterfaceDescriptor, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.fullname);

    const interfaceAcceptingMessages = message.interfaceAcceptingMessages;
    for (let i = 0; i < interfaceAcceptingMessages.length; ++i) {
      writer.uint32(18);
      writer.fork();
      InterfaceAcceptingMessageDescriptor.encode(
        interfaceAcceptingMessages[i],
        writer
      );
      writer.ldelim();
    }

    const interfaceImplementers = message.interfaceImplementers;
    for (let i = 0; i < interfaceImplementers.length; ++i) {
      writer.uint32(26);
      writer.fork();
      InterfaceImplementerDescriptor.encode(interfaceImplementers[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): InterfaceDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new InterfaceDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;

        case 2:
          message.interfaceAcceptingMessages.push(
            InterfaceAcceptingMessageDescriptor.decode(reader, reader.uint32())
          );
          break;

        case 3:
          message.interfaceImplementers.push(
            InterfaceImplementerDescriptor.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  fullname: string;
  interfaceAcceptingMessages: Array<InterfaceAcceptingMessageDescriptor>;
  interfaceImplementers: Array<InterfaceImplementerDescriptor>;

  constructor(
    fullname: string = "",
    interfaceAcceptingMessages: Array<InterfaceAcceptingMessageDescriptor> = [],
    interfaceImplementers: Array<InterfaceImplementerDescriptor> = []
  ) {
    this.fullname = fullname;
    this.interfaceAcceptingMessages = interfaceAcceptingMessages;
    this.interfaceImplementers = interfaceImplementers;
  }
}

export function encodeInterfaceDescriptor(
  message: InterfaceDescriptor
): Uint8Array {
  return Protobuf.encode(message, InterfaceDescriptor.encode);
}

export function decodeInterfaceDescriptor(
  buffer: Uint8Array
): InterfaceDescriptor {
  return Protobuf.decode<InterfaceDescriptor>(
    buffer,
    InterfaceDescriptor.decode
  );
}

export class InterfaceImplementerDescriptor {
  static encode(message: InterfaceImplementerDescriptor, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.fullname);

    writer.uint32(18);
    writer.string(message.typeUrl);
  }

  static decode(reader: Reader, length: i32): InterfaceImplementerDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new InterfaceImplementerDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;

        case 2:
          message.typeUrl = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  fullname: string;
  typeUrl: string;

  constructor(fullname: string = "", typeUrl: string = "") {
    this.fullname = fullname;
    this.typeUrl = typeUrl;
  }
}

export function encodeInterfaceImplementerDescriptor(
  message: InterfaceImplementerDescriptor
): Uint8Array {
  return Protobuf.encode(message, InterfaceImplementerDescriptor.encode);
}

export function decodeInterfaceImplementerDescriptor(
  buffer: Uint8Array
): InterfaceImplementerDescriptor {
  return Protobuf.decode<InterfaceImplementerDescriptor>(
    buffer,
    InterfaceImplementerDescriptor.decode
  );
}

export class InterfaceAcceptingMessageDescriptor {
  static encode(
    message: InterfaceAcceptingMessageDescriptor,
    writer: Writer
  ): void {
    writer.uint32(10);
    writer.string(message.fullname);

    const fieldDescriptorNames = message.fieldDescriptorNames;
    if (fieldDescriptorNames.length !== 0) {
      for (let i = 0; i < fieldDescriptorNames.length; ++i) {
        writer.uint32(18);
        writer.string(fieldDescriptorNames[i]);
      }
    }
  }

  static decode(
    reader: Reader,
    length: i32
  ): InterfaceAcceptingMessageDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new InterfaceAcceptingMessageDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;

        case 2:
          message.fieldDescriptorNames.push(reader.string());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  fullname: string;
  fieldDescriptorNames: Array<string>;

  constructor(fullname: string = "", fieldDescriptorNames: Array<string> = []) {
    this.fullname = fullname;
    this.fieldDescriptorNames = fieldDescriptorNames;
  }
}

export function encodeInterfaceAcceptingMessageDescriptor(
  message: InterfaceAcceptingMessageDescriptor
): Uint8Array {
  return Protobuf.encode(message, InterfaceAcceptingMessageDescriptor.encode);
}

export function decodeInterfaceAcceptingMessageDescriptor(
  buffer: Uint8Array
): InterfaceAcceptingMessageDescriptor {
  return Protobuf.decode<InterfaceAcceptingMessageDescriptor>(
    buffer,
    InterfaceAcceptingMessageDescriptor.decode
  );
}

export class ConfigurationDescriptor {
  static encode(message: ConfigurationDescriptor, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.bech32AccountAddressPrefix);
  }

  static decode(reader: Reader, length: i32): ConfigurationDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ConfigurationDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.bech32AccountAddressPrefix = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  bech32AccountAddressPrefix: string;

  constructor(bech32AccountAddressPrefix: string = "") {
    this.bech32AccountAddressPrefix = bech32AccountAddressPrefix;
  }
}

export function encodeConfigurationDescriptor(
  message: ConfigurationDescriptor
): Uint8Array {
  return Protobuf.encode(message, ConfigurationDescriptor.encode);
}

export function decodeConfigurationDescriptor(
  buffer: Uint8Array
): ConfigurationDescriptor {
  return Protobuf.decode<ConfigurationDescriptor>(
    buffer,
    ConfigurationDescriptor.decode
  );
}

export class MsgDescriptor {
  static encode(message: MsgDescriptor, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.msgTypeUrl);
  }

  static decode(reader: Reader, length: i32): MsgDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msgTypeUrl = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  msgTypeUrl: string;

  constructor(msgTypeUrl: string = "") {
    this.msgTypeUrl = msgTypeUrl;
  }
}

export function encodeMsgDescriptor(message: MsgDescriptor): Uint8Array {
  return Protobuf.encode(message, MsgDescriptor.encode);
}

export function decodeMsgDescriptor(buffer: Uint8Array): MsgDescriptor {
  return Protobuf.decode<MsgDescriptor>(buffer, MsgDescriptor.decode);
}

@unmanaged
export class GetAuthnDescriptorRequest {
  static encode(message: GetAuthnDescriptorRequest, writer: Writer): void {}

  static decode(reader: Reader, length: i32): GetAuthnDescriptorRequest {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetAuthnDescriptorRequest();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeGetAuthnDescriptorRequest(
  message: GetAuthnDescriptorRequest
): Uint8Array {
  return Protobuf.encode(message, GetAuthnDescriptorRequest.encode);
}

export function decodeGetAuthnDescriptorRequest(
  buffer: Uint8Array
): GetAuthnDescriptorRequest {
  return Protobuf.decode<GetAuthnDescriptorRequest>(
    buffer,
    GetAuthnDescriptorRequest.decode
  );
}

export class GetAuthnDescriptorResponse {
  static encode(message: GetAuthnDescriptorResponse, writer: Writer): void {
    const authn = message.authn;
    if (authn !== null) {
      writer.uint32(10);
      writer.fork();
      AuthnDescriptor.encode(authn, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): GetAuthnDescriptorResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetAuthnDescriptorResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.authn = AuthnDescriptor.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  authn: AuthnDescriptor | null;

  constructor(authn: AuthnDescriptor | null = null) {
    this.authn = authn;
  }
}

export function encodeGetAuthnDescriptorResponse(
  message: GetAuthnDescriptorResponse
): Uint8Array {
  return Protobuf.encode(message, GetAuthnDescriptorResponse.encode);
}

export function decodeGetAuthnDescriptorResponse(
  buffer: Uint8Array
): GetAuthnDescriptorResponse {
  return Protobuf.decode<GetAuthnDescriptorResponse>(
    buffer,
    GetAuthnDescriptorResponse.decode
  );
}

@unmanaged
export class GetChainDescriptorRequest {
  static encode(message: GetChainDescriptorRequest, writer: Writer): void {}

  static decode(reader: Reader, length: i32): GetChainDescriptorRequest {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetChainDescriptorRequest();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeGetChainDescriptorRequest(
  message: GetChainDescriptorRequest
): Uint8Array {
  return Protobuf.encode(message, GetChainDescriptorRequest.encode);
}

export function decodeGetChainDescriptorRequest(
  buffer: Uint8Array
): GetChainDescriptorRequest {
  return Protobuf.decode<GetChainDescriptorRequest>(
    buffer,
    GetChainDescriptorRequest.decode
  );
}

export class GetChainDescriptorResponse {
  static encode(message: GetChainDescriptorResponse, writer: Writer): void {
    const chain = message.chain;
    if (chain !== null) {
      writer.uint32(10);
      writer.fork();
      ChainDescriptor.encode(chain, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): GetChainDescriptorResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetChainDescriptorResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.chain = ChainDescriptor.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  chain: ChainDescriptor | null;

  constructor(chain: ChainDescriptor | null = null) {
    this.chain = chain;
  }
}

export function encodeGetChainDescriptorResponse(
  message: GetChainDescriptorResponse
): Uint8Array {
  return Protobuf.encode(message, GetChainDescriptorResponse.encode);
}

export function decodeGetChainDescriptorResponse(
  buffer: Uint8Array
): GetChainDescriptorResponse {
  return Protobuf.decode<GetChainDescriptorResponse>(
    buffer,
    GetChainDescriptorResponse.decode
  );
}

@unmanaged
export class GetCodecDescriptorRequest {
  static encode(message: GetCodecDescriptorRequest, writer: Writer): void {}

  static decode(reader: Reader, length: i32): GetCodecDescriptorRequest {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetCodecDescriptorRequest();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeGetCodecDescriptorRequest(
  message: GetCodecDescriptorRequest
): Uint8Array {
  return Protobuf.encode(message, GetCodecDescriptorRequest.encode);
}

export function decodeGetCodecDescriptorRequest(
  buffer: Uint8Array
): GetCodecDescriptorRequest {
  return Protobuf.decode<GetCodecDescriptorRequest>(
    buffer,
    GetCodecDescriptorRequest.decode
  );
}

export class GetCodecDescriptorResponse {
  static encode(message: GetCodecDescriptorResponse, writer: Writer): void {
    const codec = message.codec;
    if (codec !== null) {
      writer.uint32(10);
      writer.fork();
      CodecDescriptor.encode(codec, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): GetCodecDescriptorResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetCodecDescriptorResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.codec = CodecDescriptor.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  codec: CodecDescriptor | null;

  constructor(codec: CodecDescriptor | null = null) {
    this.codec = codec;
  }
}

export function encodeGetCodecDescriptorResponse(
  message: GetCodecDescriptorResponse
): Uint8Array {
  return Protobuf.encode(message, GetCodecDescriptorResponse.encode);
}

export function decodeGetCodecDescriptorResponse(
  buffer: Uint8Array
): GetCodecDescriptorResponse {
  return Protobuf.decode<GetCodecDescriptorResponse>(
    buffer,
    GetCodecDescriptorResponse.decode
  );
}

@unmanaged
export class GetConfigurationDescriptorRequest {
  static encode(
    message: GetConfigurationDescriptorRequest,
    writer: Writer
  ): void {}

  static decode(
    reader: Reader,
    length: i32
  ): GetConfigurationDescriptorRequest {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetConfigurationDescriptorRequest();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeGetConfigurationDescriptorRequest(
  message: GetConfigurationDescriptorRequest
): Uint8Array {
  return Protobuf.encode(message, GetConfigurationDescriptorRequest.encode);
}

export function decodeGetConfigurationDescriptorRequest(
  buffer: Uint8Array
): GetConfigurationDescriptorRequest {
  return Protobuf.decode<GetConfigurationDescriptorRequest>(
    buffer,
    GetConfigurationDescriptorRequest.decode
  );
}

export class GetConfigurationDescriptorResponse {
  static encode(
    message: GetConfigurationDescriptorResponse,
    writer: Writer
  ): void {
    const config = message.config;
    if (config !== null) {
      writer.uint32(10);
      writer.fork();
      ConfigurationDescriptor.encode(config, writer);
      writer.ldelim();
    }
  }

  static decode(
    reader: Reader,
    length: i32
  ): GetConfigurationDescriptorResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetConfigurationDescriptorResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.config = ConfigurationDescriptor.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  config: ConfigurationDescriptor | null;

  constructor(config: ConfigurationDescriptor | null = null) {
    this.config = config;
  }
}

export function encodeGetConfigurationDescriptorResponse(
  message: GetConfigurationDescriptorResponse
): Uint8Array {
  return Protobuf.encode(message, GetConfigurationDescriptorResponse.encode);
}

export function decodeGetConfigurationDescriptorResponse(
  buffer: Uint8Array
): GetConfigurationDescriptorResponse {
  return Protobuf.decode<GetConfigurationDescriptorResponse>(
    buffer,
    GetConfigurationDescriptorResponse.decode
  );
}

@unmanaged
export class GetQueryServicesDescriptorRequest {
  static encode(
    message: GetQueryServicesDescriptorRequest,
    writer: Writer
  ): void {}

  static decode(
    reader: Reader,
    length: i32
  ): GetQueryServicesDescriptorRequest {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetQueryServicesDescriptorRequest();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeGetQueryServicesDescriptorRequest(
  message: GetQueryServicesDescriptorRequest
): Uint8Array {
  return Protobuf.encode(message, GetQueryServicesDescriptorRequest.encode);
}

export function decodeGetQueryServicesDescriptorRequest(
  buffer: Uint8Array
): GetQueryServicesDescriptorRequest {
  return Protobuf.decode<GetQueryServicesDescriptorRequest>(
    buffer,
    GetQueryServicesDescriptorRequest.decode
  );
}

export class GetQueryServicesDescriptorResponse {
  static encode(
    message: GetQueryServicesDescriptorResponse,
    writer: Writer
  ): void {
    const queries = message.queries;
    if (queries !== null) {
      writer.uint32(10);
      writer.fork();
      QueryServicesDescriptor.encode(queries, writer);
      writer.ldelim();
    }
  }

  static decode(
    reader: Reader,
    length: i32
  ): GetQueryServicesDescriptorResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetQueryServicesDescriptorResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.queries = QueryServicesDescriptor.decode(
            reader,
            reader.uint32()
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  queries: QueryServicesDescriptor | null;

  constructor(queries: QueryServicesDescriptor | null = null) {
    this.queries = queries;
  }
}

export function encodeGetQueryServicesDescriptorResponse(
  message: GetQueryServicesDescriptorResponse
): Uint8Array {
  return Protobuf.encode(message, GetQueryServicesDescriptorResponse.encode);
}

export function decodeGetQueryServicesDescriptorResponse(
  buffer: Uint8Array
): GetQueryServicesDescriptorResponse {
  return Protobuf.decode<GetQueryServicesDescriptorResponse>(
    buffer,
    GetQueryServicesDescriptorResponse.decode
  );
}

@unmanaged
export class GetTxDescriptorRequest {
  static encode(message: GetTxDescriptorRequest, writer: Writer): void {}

  static decode(reader: Reader, length: i32): GetTxDescriptorRequest {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetTxDescriptorRequest();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  constructor() {}
}

export function encodeGetTxDescriptorRequest(
  message: GetTxDescriptorRequest
): Uint8Array {
  return Protobuf.encode(message, GetTxDescriptorRequest.encode);
}

export function decodeGetTxDescriptorRequest(
  buffer: Uint8Array
): GetTxDescriptorRequest {
  return Protobuf.decode<GetTxDescriptorRequest>(
    buffer,
    GetTxDescriptorRequest.decode
  );
}

export class GetTxDescriptorResponse {
  static encode(message: GetTxDescriptorResponse, writer: Writer): void {
    const tx = message.tx;
    if (tx !== null) {
      writer.uint32(10);
      writer.fork();
      TxDescriptor.encode(tx, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): GetTxDescriptorResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GetTxDescriptorResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tx = TxDescriptor.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  tx: TxDescriptor | null;

  constructor(tx: TxDescriptor | null = null) {
    this.tx = tx;
  }
}

export function encodeGetTxDescriptorResponse(
  message: GetTxDescriptorResponse
): Uint8Array {
  return Protobuf.encode(message, GetTxDescriptorResponse.encode);
}

export function decodeGetTxDescriptorResponse(
  buffer: Uint8Array
): GetTxDescriptorResponse {
  return Protobuf.decode<GetTxDescriptorResponse>(
    buffer,
    GetTxDescriptorResponse.decode
  );
}

export class QueryServicesDescriptor {
  static encode(message: QueryServicesDescriptor, writer: Writer): void {
    const queryServices = message.queryServices;
    for (let i = 0; i < queryServices.length; ++i) {
      writer.uint32(10);
      writer.fork();
      QueryServiceDescriptor.encode(queryServices[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): QueryServicesDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new QueryServicesDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.queryServices.push(
            QueryServiceDescriptor.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  queryServices: Array<QueryServiceDescriptor>;

  constructor(queryServices: Array<QueryServiceDescriptor> = []) {
    this.queryServices = queryServices;
  }
}

export function encodeQueryServicesDescriptor(
  message: QueryServicesDescriptor
): Uint8Array {
  return Protobuf.encode(message, QueryServicesDescriptor.encode);
}

export function decodeQueryServicesDescriptor(
  buffer: Uint8Array
): QueryServicesDescriptor {
  return Protobuf.decode<QueryServicesDescriptor>(
    buffer,
    QueryServicesDescriptor.decode
  );
}

export class QueryServiceDescriptor {
  static encode(message: QueryServiceDescriptor, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.fullname);

    writer.uint32(16);
    writer.bool(message.isModule);

    const methods = message.methods;
    for (let i = 0; i < methods.length; ++i) {
      writer.uint32(26);
      writer.fork();
      QueryMethodDescriptor.encode(methods[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): QueryServiceDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new QueryServiceDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.fullname = reader.string();
          break;

        case 2:
          message.isModule = reader.bool();
          break;

        case 3:
          message.methods.push(
            QueryMethodDescriptor.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  fullname: string;
  isModule: bool;
  methods: Array<QueryMethodDescriptor>;

  constructor(
    fullname: string = "",
    isModule: bool = false,
    methods: Array<QueryMethodDescriptor> = []
  ) {
    this.fullname = fullname;
    this.isModule = isModule;
    this.methods = methods;
  }
}

export function encodeQueryServiceDescriptor(
  message: QueryServiceDescriptor
): Uint8Array {
  return Protobuf.encode(message, QueryServiceDescriptor.encode);
}

export function decodeQueryServiceDescriptor(
  buffer: Uint8Array
): QueryServiceDescriptor {
  return Protobuf.decode<QueryServiceDescriptor>(
    buffer,
    QueryServiceDescriptor.decode
  );
}

export class QueryMethodDescriptor {
  static encode(message: QueryMethodDescriptor, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.name);

    writer.uint32(18);
    writer.string(message.fullQueryPath);
  }

  static decode(reader: Reader, length: i32): QueryMethodDescriptor {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new QueryMethodDescriptor();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;

        case 2:
          message.fullQueryPath = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  name: string;
  fullQueryPath: string;

  constructor(name: string = "", fullQueryPath: string = "") {
    this.name = name;
    this.fullQueryPath = fullQueryPath;
  }
}

export function encodeQueryMethodDescriptor(
  message: QueryMethodDescriptor
): Uint8Array {
  return Protobuf.encode(message, QueryMethodDescriptor.encode);
}

export function decodeQueryMethodDescriptor(
  buffer: Uint8Array
): QueryMethodDescriptor {
  return Protobuf.decode<QueryMethodDescriptor>(
    buffer,
    QueryMethodDescriptor.decode
  );
}
