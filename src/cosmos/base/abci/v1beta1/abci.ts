// Code generated by protoc-gen-as. DO NOT EDIT.
// Versions:
//   protoc-gen-as v0.4.0
//   protoc        v3.21.6

import { Writer, Reader, Protobuf } from "as-proto";
import { google } from "../../../../google";
import { tendermint } from "../../../../tendermint";

export class TxResponse {
  static encode(message: TxResponse, writer: Writer): void {
    writer.uint32(8);
    writer.int64(message.height);

    writer.uint32(18);
    writer.string(message.txhash);

    writer.uint32(26);
    writer.string(message.codespace);

    writer.uint32(32);
    writer.uint32(message.code);

    writer.uint32(42);
    writer.string(message.data);

    writer.uint32(50);
    writer.string(message.rawLog);

    const logs = message.logs;
    for (let i = 0; i < logs.length; ++i) {
      writer.uint32(58);
      writer.fork();
      ABCIMessageLog.encode(logs[i], writer);
      writer.ldelim();
    }

    writer.uint32(66);
    writer.string(message.info);

    writer.uint32(72);
    writer.int64(message.gasWanted);

    writer.uint32(80);
    writer.int64(message.gasUsed);

    const tx = message.tx;
    if (tx !== null) {
      writer.uint32(90);
      writer.fork();
      google.protobuf.Any.encode(tx, writer);
      writer.ldelim();
    }

    writer.uint32(98);
    writer.string(message.timestamp);

    const events = message.events;
    for (let i = 0; i < events.length; ++i) {
      writer.uint32(106);
      writer.fork();
      tendermint.abci.Event.encode(events[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): TxResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new TxResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.height = reader.int64();
          break;

        case 2:
          message.txhash = reader.string();
          break;

        case 3:
          message.codespace = reader.string();
          break;

        case 4:
          message.code = reader.uint32();
          break;

        case 5:
          message.data = reader.string();
          break;

        case 6:
          message.rawLog = reader.string();
          break;

        case 7:
          message.logs.push(ABCIMessageLog.decode(reader, reader.uint32()));
          break;

        case 8:
          message.info = reader.string();
          break;

        case 9:
          message.gasWanted = reader.int64();
          break;

        case 10:
          message.gasUsed = reader.int64();
          break;

        case 11:
          message.tx = google.protobuf.Any.decode(reader, reader.uint32());
          break;

        case 12:
          message.timestamp = reader.string();
          break;

        case 13:
          message.events.push(
            tendermint.abci.Event.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  height: i64;
  txhash: string;
  codespace: string;
  code: u32;
  data: string;
  rawLog: string;
  logs: Array<ABCIMessageLog>;
  info: string;
  gasWanted: i64;
  gasUsed: i64;
  tx: google.protobuf.Any | null;
  timestamp: string;
  events: Array<tendermint.abci.Event>;

  constructor(
    height: i64 = 0,
    txhash: string = "",
    codespace: string = "",
    code: u32 = 0,
    data: string = "",
    rawLog: string = "",
    logs: Array<ABCIMessageLog> = [],
    info: string = "",
    gasWanted: i64 = 0,
    gasUsed: i64 = 0,
    tx: google.protobuf.Any | null = null,
    timestamp: string = "",
    events: Array<tendermint.abci.Event> = []
  ) {
    this.height = height;
    this.txhash = txhash;
    this.codespace = codespace;
    this.code = code;
    this.data = data;
    this.rawLog = rawLog;
    this.logs = logs;
    this.info = info;
    this.gasWanted = gasWanted;
    this.gasUsed = gasUsed;
    this.tx = tx;
    this.timestamp = timestamp;
    this.events = events;
  }
}

export function encodeTxResponse(message: TxResponse): Uint8Array {
  return Protobuf.encode(message, TxResponse.encode);
}

export function decodeTxResponse(buffer: Uint8Array): TxResponse {
  return Protobuf.decode<TxResponse>(buffer, TxResponse.decode);
}

export class ABCIMessageLog {
  static encode(message: ABCIMessageLog, writer: Writer): void {
    writer.uint32(8);
    writer.uint32(message.msgIndex);

    writer.uint32(18);
    writer.string(message.log);

    const events = message.events;
    for (let i = 0; i < events.length; ++i) {
      writer.uint32(26);
      writer.fork();
      StringEvent.encode(events[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): ABCIMessageLog {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new ABCIMessageLog();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msgIndex = reader.uint32();
          break;

        case 2:
          message.log = reader.string();
          break;

        case 3:
          message.events.push(StringEvent.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  msgIndex: u32;
  log: string;
  events: Array<StringEvent>;

  constructor(
    msgIndex: u32 = 0,
    log: string = "",
    events: Array<StringEvent> = []
  ) {
    this.msgIndex = msgIndex;
    this.log = log;
    this.events = events;
  }
}

export function encodeABCIMessageLog(message: ABCIMessageLog): Uint8Array {
  return Protobuf.encode(message, ABCIMessageLog.encode);
}

export function decodeABCIMessageLog(buffer: Uint8Array): ABCIMessageLog {
  return Protobuf.decode<ABCIMessageLog>(buffer, ABCIMessageLog.decode);
}

export class StringEvent {
  static encode(message: StringEvent, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.type);

    const attributes = message.attributes;
    for (let i = 0; i < attributes.length; ++i) {
      writer.uint32(18);
      writer.fork();
      Attribute.encode(attributes[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): StringEvent {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new StringEvent();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.type = reader.string();
          break;

        case 2:
          message.attributes.push(Attribute.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  type: string;
  attributes: Array<Attribute>;

  constructor(type: string = "", attributes: Array<Attribute> = []) {
    this.type = type;
    this.attributes = attributes;
  }
}

export function encodeStringEvent(message: StringEvent): Uint8Array {
  return Protobuf.encode(message, StringEvent.encode);
}

export function decodeStringEvent(buffer: Uint8Array): StringEvent {
  return Protobuf.decode<StringEvent>(buffer, StringEvent.decode);
}

export class Attribute {
  static encode(message: Attribute, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.key);

    writer.uint32(18);
    writer.string(message.value);
  }

  static decode(reader: Reader, length: i32): Attribute {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Attribute();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;

        case 2:
          message.value = reader.string();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  key: string;
  value: string;

  constructor(key: string = "", value: string = "") {
    this.key = key;
    this.value = value;
  }
}

export function encodeAttribute(message: Attribute): Uint8Array {
  return Protobuf.encode(message, Attribute.encode);
}

export function decodeAttribute(buffer: Uint8Array): Attribute {
  return Protobuf.decode<Attribute>(buffer, Attribute.decode);
}

@unmanaged
export class GasInfo {
  static encode(message: GasInfo, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.gasWanted);

    writer.uint32(16);
    writer.uint64(message.gasUsed);
  }

  static decode(reader: Reader, length: i32): GasInfo {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new GasInfo();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gasWanted = reader.uint64();
          break;

        case 2:
          message.gasUsed = reader.uint64();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  gasWanted: u64;
  gasUsed: u64;

  constructor(gasWanted: u64 = 0, gasUsed: u64 = 0) {
    this.gasWanted = gasWanted;
    this.gasUsed = gasUsed;
  }
}

export function encodeGasInfo(message: GasInfo): Uint8Array {
  return Protobuf.encode(message, GasInfo.encode);
}

export function decodeGasInfo(buffer: Uint8Array): GasInfo {
  return Protobuf.decode<GasInfo>(buffer, GasInfo.decode);
}

export class Result {
  static encode(message: Result, writer: Writer): void {
    writer.uint32(10);
    writer.bytes(message.data);

    writer.uint32(18);
    writer.string(message.log);

    const events = message.events;
    for (let i = 0; i < events.length; ++i) {
      writer.uint32(26);
      writer.fork();
      tendermint.abci.Event.encode(events[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): Result {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new Result();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.data = reader.bytes();
          break;

        case 2:
          message.log = reader.string();
          break;

        case 3:
          message.events.push(
            tendermint.abci.Event.decode(reader, reader.uint32())
          );
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  data: Uint8Array;
  log: string;
  events: Array<tendermint.abci.Event>;

  constructor(
    data: Uint8Array = new Uint8Array(0),
    log: string = "",
    events: Array<tendermint.abci.Event> = []
  ) {
    this.data = data;
    this.log = log;
    this.events = events;
  }
}

export function encodeResult(message: Result): Uint8Array {
  return Protobuf.encode(message, Result.encode);
}

export function decodeResult(buffer: Uint8Array): Result {
  return Protobuf.decode<Result>(buffer, Result.decode);
}

export class SimulationResponse {
  static encode(message: SimulationResponse, writer: Writer): void {
    const gasInfo = message.gasInfo;
    if (gasInfo !== null) {
      writer.uint32(10);
      writer.fork();
      GasInfo.encode(gasInfo, writer);
      writer.ldelim();
    }

    const result = message.result;
    if (result !== null) {
      writer.uint32(18);
      writer.fork();
      Result.encode(result, writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): SimulationResponse {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new SimulationResponse();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.gasInfo = GasInfo.decode(reader, reader.uint32());
          break;

        case 2:
          message.result = Result.decode(reader, reader.uint32());
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  gasInfo: GasInfo | null;
  result: Result | null;

  constructor(gasInfo: GasInfo | null = null, result: Result | null = null) {
    this.gasInfo = gasInfo;
    this.result = result;
  }
}

export function encodeSimulationResponse(
  message: SimulationResponse
): Uint8Array {
  return Protobuf.encode(message, SimulationResponse.encode);
}

export function decodeSimulationResponse(
  buffer: Uint8Array
): SimulationResponse {
  return Protobuf.decode<SimulationResponse>(buffer, SimulationResponse.decode);
}

export class MsgData {
  static encode(message: MsgData, writer: Writer): void {
    writer.uint32(10);
    writer.string(message.msgType);

    writer.uint32(18);
    writer.bytes(message.data);
  }

  static decode(reader: Reader, length: i32): MsgData {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new MsgData();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.msgType = reader.string();
          break;

        case 2:
          message.data = reader.bytes();
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  msgType: string;
  data: Uint8Array;

  constructor(msgType: string = "", data: Uint8Array = new Uint8Array(0)) {
    this.msgType = msgType;
    this.data = data;
  }
}

export function encodeMsgData(message: MsgData): Uint8Array {
  return Protobuf.encode(message, MsgData.encode);
}

export function decodeMsgData(buffer: Uint8Array): MsgData {
  return Protobuf.decode<MsgData>(buffer, MsgData.decode);
}

export class TxMsgData {
  static encode(message: TxMsgData, writer: Writer): void {
    const data = message.data;
    for (let i = 0; i < data.length; ++i) {
      writer.uint32(10);
      writer.fork();
      MsgData.encode(data[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): TxMsgData {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new TxMsgData();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.data.push(MsgData.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  data: Array<MsgData>;

  constructor(data: Array<MsgData> = []) {
    this.data = data;
  }
}

export function encodeTxMsgData(message: TxMsgData): Uint8Array {
  return Protobuf.encode(message, TxMsgData.encode);
}

export function decodeTxMsgData(buffer: Uint8Array): TxMsgData {
  return Protobuf.decode<TxMsgData>(buffer, TxMsgData.decode);
}

export class SearchTxsResult {
  static encode(message: SearchTxsResult, writer: Writer): void {
    writer.uint32(8);
    writer.uint64(message.totalCount);

    writer.uint32(16);
    writer.uint64(message.count);

    writer.uint32(24);
    writer.uint64(message.pageNumber);

    writer.uint32(32);
    writer.uint64(message.pageTotal);

    writer.uint32(40);
    writer.uint64(message.limit);

    const txs = message.txs;
    for (let i = 0; i < txs.length; ++i) {
      writer.uint32(50);
      writer.fork();
      TxResponse.encode(txs[i], writer);
      writer.ldelim();
    }
  }

  static decode(reader: Reader, length: i32): SearchTxsResult {
    const end: usize = length < 0 ? reader.end : reader.ptr + length;
    const message = new SearchTxsResult();

    while (reader.ptr < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.totalCount = reader.uint64();
          break;

        case 2:
          message.count = reader.uint64();
          break;

        case 3:
          message.pageNumber = reader.uint64();
          break;

        case 4:
          message.pageTotal = reader.uint64();
          break;

        case 5:
          message.limit = reader.uint64();
          break;

        case 6:
          message.txs.push(TxResponse.decode(reader, reader.uint32()));
          break;

        default:
          reader.skipType(tag & 7);
          break;
      }
    }

    return message;
  }

  totalCount: u64;
  count: u64;
  pageNumber: u64;
  pageTotal: u64;
  limit: u64;
  txs: Array<TxResponse>;

  constructor(
    totalCount: u64 = 0,
    count: u64 = 0,
    pageNumber: u64 = 0,
    pageTotal: u64 = 0,
    limit: u64 = 0,
    txs: Array<TxResponse> = []
  ) {
    this.totalCount = totalCount;
    this.count = count;
    this.pageNumber = pageNumber;
    this.pageTotal = pageTotal;
    this.limit = limit;
    this.txs = txs;
  }
}

export function encodeSearchTxsResult(message: SearchTxsResult): Uint8Array {
  return Protobuf.encode(message, SearchTxsResult.encode);
}

export function decodeSearchTxsResult(buffer: Uint8Array): SearchTxsResult {
  return Protobuf.decode<SearchTxsResult>(buffer, SearchTxsResult.decode);
}
